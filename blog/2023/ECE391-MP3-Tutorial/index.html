<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>ECE391-MP3-Tutorial | Zicheng Ma</title> <meta name="author" content="Zicheng Ma"> <meta name="description" content="A tutorial and tips for ECE391 MP3."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://zichengma.github.io/blog/2023/ECE391-MP3-Tutorial/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Zicheng </span>Ma</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/projects/">projects</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">ECE391-MP3-Tutorial</h1> <p class="post-meta">January 13, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/category/course-notes"> <i class="fas fa-tag fa-sm"></i> course-notes</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <h1 id="ece391-mp3">ECE391 MP3</h1> <blockquote> <p><strong><em>Notes about all the documents and materials related to ECE391 MP3.</em></strong></p> </blockquote> <blockquote> <p><strong><em>FA22 Group 11 — ZinixOS</em></strong></p> </blockquote> <blockquote> <p>Mmebers: Zicheng Ma, Ziyuan Chen, Zhirong Chen, Shihua Zeng</p> </blockquote> <blockquote> <p>Language: 中文+English</p> </blockquote> <p>FA22 ECE391本人最终评分A+，侧面表明这篇文档在一定程度上还是可以信赖的，而且有我的队友对文档进行查改和补充<del><em>但如果写出bug，本人概不负责</em></del> 🤣 😋</p> <p>REFERENCE: OSdev相关资料，TA Jerry Wang’s slides</p> <h1 id="checkpoint-1">Checkpoint 1</h1> <h2 id="os-booting-gdt--idt-setup">OS Booting: GDT &amp; IDT Setup</h2> <h3 id="gdt">GDT</h3> <p>reference: <a href="https://wiki.osdev.org/Global_Descriptor_Table" rel="external nofollow noopener" target="_blank">https://wiki.osdev.org/Global_Descriptor_Table</a></p> <p>在<code class="language-plaintext highlighter-rouge">x86_desc.S</code>中创建<code class="language-plaintext highlighter-rouge">gdt_desc</code>标记（参考<code class="language-plaintext highlighter-rouge">ldt_desc</code>）</p> <ul> <li>48bytes，包括<code class="language-plaintext highlighter-rouge">.word</code>长度的limit和<code class="language-plaintext highlighter-rouge">.long</code>长度的base</li> </ul> <p>在<code class="language-plaintext highlighter-rouge">boot.S</code>中用<code class="language-plaintext highlighter-rouge">lgdt gdt_desc</code>载入</p> <h3 id="idt">IDT</h3> <p>reference: <a href="https://wiki.osdev.org/Interrupt_Descriptor_Table" rel="external nofollow noopener" target="_blank">https://wiki.osdev.org/Interrupt_Descriptor_Table</a></p> <p>在<code class="language-plaintext highlighter-rouge">interrupt.c</code>中定义handlers</p> <ul> <li>对于Exception，打印错误信息+无限循环（“蓝屏”）<strong>（后续ckpt会处理如何跳出无限循环）</strong> </li> <li>对于Interrupt，在函数体中调用linkage<strong>**</strong><strong>**</strong>（无参数）<strong>**</strong><strong>**</strong>，在asm中定义linkage函数（Push all, call handler, pop all, <strong>**</strong><strong>iret</strong><strong>**</strong>） <ul> <li>需要调用linkage的原因是，C function在结束后默认使用ret，而interrupt结束后需要从kernel跳回到user space，使用的是iret。利用asm linkage来完成这一步跳转，用C function来完成每个interrupt handler的具体工作。</li> </ul> </li> <li>利用定义好的SET_IDT_ENTRY来设置IDT中指向的linkage/function</li> </ul> <h2 id="device-and-interrupt">Device and Interrupt</h2> <hr> <h3 id="pic">PIC</h3> <p>reference:<a href="https://wiki.osdev.org/PIC" rel="external nofollow noopener" target="_blank">https://wiki.osdev.org/PIC</a></p> <p>PIC所使用port位置</p> <p><img src="Untitled.png" alt="Untitled"></p> <p>在IDT中，PIC_MASTER使用<strong>0x20-0x27</strong> vector呼叫handler，PIC_SLAVE使用<strong>0x28-0x2F</strong>呼叫handler</p> <p>PIC_SLAVE链接到PIC_MASTER的<strong>2号vector</strong></p> <hr> <p><strong><em>Initialization:</em></strong></p> <ol> <li>mask掉所有interrupt（向data port传入0xff）</li> <li>先给予0x11 command，然后PIC会等待接下来3个传入参数进行初始化（ICW1)</li> <li>接下来确定在IDT中的位置(ICW2)</li> <li>决定Master和Slave的cascade状况(ICW3)</li> <li>最后向Data port传入这是x86模式，以适配x86模式进行工作</li> </ol> <p>主要对着Lecture10 PPT写即可</p> <hr> <p><strong><em>enable_irq / disable_irq:</em></strong></p> <p>PIC内部存在一个register Interrupt Mask Register，共8bit，当对应bit位被set为1时，PIC会忽略对应位置irq。注意: mask数字高的irq不会影响数字低的irq（priority更高的irq）</p> <p>先判断irq是否超过7，若超过7，向PIC_SLAVE的data port传入数据，否则向PIC_MASTERdata port传入数据</p> <p><img src="Untitled1.png" alt="Untitled" style="zoom:50%;"></p> <p><img src="Untitled2.png" alt="Untitled" style="zoom:50%;"></p> <hr> <p><strong><em>send_EOI:</em></strong></p> <p>同样需要检查irq number。无论如何都要给MASTER command port send EOI，如果是SLAVE的handler结束，那就给SLAVE也补上</p> <p>注意: 我们的代码中EOI在send之前需要和irq做一个OR操作，以告知PIC是哪一个irq结束</p> <p><img src="Untitled3.png" alt="Untitled"></p> <p>补充：以上函数均需要做<strong>sanity check</strong>，不允许传入的irq number是一个0-15以外的数值</p> <hr> <h3 id="rtc">RTC</h3> <p>RTC可以以多个频率运行，基础频率32.768kHz，可以用divider register改变，但是不要变，要不然不准。对于interrupt，默认产生interrupt的频率是1024Hz，可以自行修改，the RTC can theoretically generate <strong>15 interrupt rates between 2 Hz and 32768 Hz (</strong>2^1-2^15)</p> <p>RTC handler期间，禁用NMI，否则导致RTC变成不可用状态</p> <p>RTC使用<strong>port 0x70和0x71</strong>，0x70用来指示用哪个register，0x71包含数据。在选择register时可以顺带mask掉NMI</p> <p><img src="Untitled4.png" alt="Untitled"></p> <hr> <p><strong><em>Initialization:</em></strong></p> <ol> <li>打开IRQ8 这里reset原因是每次读写完之后，port 0x70的内容都会被清零，需要重新指定register，然后在这之后要<code class="language-plaintext highlighter-rouge">enable_irq(8)</code> </li> </ol> <p><img src="Untitled5.png" alt="Untitled"></p> <ol> <li> <p>选择interrupt产生的frequency</p> <p>寄存器A的低4位，是divider value，默认位0110即6，所以默认frequency = 2^15»(6-1) = 1024</p> <p>设置好寄存器A的低4位(称为rate)后，最终<strong>frequency = 2^15 »(rate-1)</strong></p> <p><strong>rate最低只能选3</strong>，低于3会roll over，导致interrupt频率不准</p> <p><img src="Untitled6.png" alt="Untitled"></p> </li> </ol> <hr> <p><strong><em>handler:</em></strong></p> <p>需要使用一个全局变量，并且需要volatile，来记录RTC产生interrupt的次数，当做时钟</p> <p>这个数字，除以frequency，就可以得到当前过了多少秒，或者多少ms</p> <ol> <li> <p><strong>if register C is not read after an IRQ 8, then the interrupt will not happen again</strong></p> <p>在每次handler之后需要加入一段</p> <p><img src="Untitled7.png" alt="Untitled"></p> </li> <li> <p>然后send_EOI，STI</p> </li> </ol> <hr> <h3 id="keyboard">Keyboard</h3> <p>键盘本身属于PS/2 controller，使用PS/2的port。读取键盘内容从<strong>0x60</strong>端口获得，<strong>connect to irq1</strong></p> <p><img src="Untitled8.png" alt="Untitled"></p> <p>command为一个byte，键盘会response “ACK” (to acknowledge the command) or a “Resend” (to say something was wrong with the previous command)</p> <p>scan code set会表示哪个键被下压。scan code可能不止一个，最多6个bytes。当keyboard状态机知道现在scan code已经全部获取了，就可以将其转化成key code了。</p> <p>我们的键盘属于US QWERTY，用SCAN CODE SET1</p> <p><strong><em>Initialization:</em></strong></p> <p>只需要enable_irq即可</p> <p><strong><em>handler:</em></strong></p> <ol> <li>从port中读取数据 <code class="language-plaintext highlighter-rouge">inb(0x60)</code> </li> <li>利用提前建好的table对应ASCII <ol> <li>检测是否为特殊键 shift caps…. 如果是，暂时不做任何操作（或者可以在这个ckpt就把这个东西弄好）</li> <li>对普通键，对应ASCII码并putc</li> </ol> </li> <li>send EOI</li> </ol> <h2 id="paging">Paging</h2> <p>reference: <a href="https://wiki.osdev.org/Paging" rel="external nofollow noopener" target="_blank">https://wiki.osdev.org/Paging</a></p> <h3 id="kernelc">kernel.c</h3> <p>在 <code class="language-plaintext highlighter-rouge">kernel.c</code> 的 <code class="language-plaintext highlighter-rouge">entry</code>函数中添加 <code class="language-plaintext highlighter-rouge">page_init</code>函数， 调用 <code class="language-plaintext highlighter-rouge">page.c</code>中初始化分页的代码</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Init the PIC */</span>
	<span class="n">i8259_init</span><span class="p">();</span>

<span class="cm">/* Init paging */</span>
	<span class="n">page_init</span><span class="p">();</span>
</code></pre></div></div> <h3 id="pagec-pageh">page.c, page.h</h3> <ol> <li>在新文件 <code class="language-plaintext highlighter-rouge">page.h</code> 以及 <code class="language-plaintext highlighter-rouge">page.c</code> 中定义相关函数和数据结构 <ul> <li>page table需要自定义数据结构，参照OSdev或者x86手册</li> </ul> </li> <li>定义函数 <ul> <li>需要完成对 <strong>page directory table</strong> 和 两个 <strong>page table</strong> 的初始化，并且写入内存中对应位置。page init部分实际上就是修改创建好的page tables中各个bit的值，对应所需要开启的paging部分</li> <li>需要操作 CPU 的 <code class="language-plaintext highlighter-rouge">cr0</code>, <code class="language-plaintext highlighter-rouge">cr3</code>, <code class="language-plaintext highlighter-rouge">cr4</code> 寄存器，告知硬件page directory的位置并为 paging 开启硬件支持。这一步相当于激活上面一步初始化好的page directory和page table</li> <li>cr0用于开启paging cr4用于开启4MB page cr3为TLB，即指示page directory位置</li> </ul> <p>page directory entry 和 page table entry 的结构：</p> <p><img src="Untitled9.png" alt="Untitled"></p> </li> </ol> <h1 id="checkpoint-2">Checkpoint 2</h1> <h2 id="terminal-driver">Terminal Driver</h2> <hr> <p>ToDo:</p> <ol> <li>完善键盘映射：Shift、CapsLock（Ctrl和Alt也需要用全局变量追踪，暂时没有更多作用——TA）</li> <li>光标追踪：让打的字出现在光标处，需要支持上下滑动（其实只有向上；可以不用保留command history）。还需要支持Ctrl+L/Ctrl+l的清屏操作</li> <li>还需要支持退格键（直接改变光标）和行缓冲输入，缓冲区大小128B</li> </ol> <p><strong>read:</strong></p> <p>从keyboard buffer中读取写入的字符，转移到terminal buffer中，返回读取的bytes总数</p> <p>设置while循环，不断通过键盘向keyboard buffer中增加内容，扫描到enter才返回。缓冲区换入127个字符时，拒绝新进入的字符（停止更新缓冲区），等待一个enter的输入。（最后一个字符应为\n）</p> <p>对于terminal，read多少字符，就把buffer中的多少个字符给清空，并将后面的挪动到前面来</p> <p><strong>**</strong><strong>**</strong><strong>**^ 其实可以直接覆写</strong><strong>**</strong><strong>**</strong>**</p> <p>read有两种情况会终止，第一种是read到指定byte数目，第二种是碰到了\n（其实只有一种？）</p> <p><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>^ 只在读到\n时返回即可，越界时直接忽略后面的字符</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong></p> <p><strong>write:</strong></p> <p>从传入的buf中读取所有内容，转移到屏幕上，返回written bytes数目或者-1</p> <p><strong>注意需要滚动换行↓的情况：打印字符计数达到80时触发scrolling函数</strong></p> <p><strong>**scrolling:</strong>**</p> <p>可能要修改putc函数，将上方所有内容向上移动一行，把最底下一行清空，然后再打印新的字符（直接更新vmem）</p> <p><strong>**clear:</strong>**</p> <p>lib.c中的clear函数只有清理video memory的操作，没有重置下一个character应该出现的位置</p> <p>↑但仍然是好事，差点就要写循环往vmem里赋零了（）</p> <h2 id="read-only-file-system">Read-only File system</h2> <hr> <p>ToDo:</p> <ol> <li>open and read a file system image</li> <li>copy program images into physical memory</li> </ol> <h3 id="基本数据结构"> <strong>**</strong><strong>基本数据结构</strong><strong>**</strong> </h3> <p>每个Block 4kB，第一个block称为boot block，包含file system的整体统计信息（dir数量、inode数量、数据块数量）和所有的directory。统计信息、每个directory均占据64B</p> <p>第一个directory总是代表当前directory，命名为.（一个点），所以实际上最多只能有62个其他files</p> <p>每一个directory包含：32B文件名（不一定要包含EOS，也即未必有”\0”标记字符串尾）、4B文件类型、4B inode索引</p> <p><img src="Untitled10.png" alt="Untitled"></p> <p>file type 0 代表user level可以触碰的RTC，1 for directory，2 for regular file。对于RTC和directory，#inode是没有意义的。</p> <p><img src="Untitled11.png" alt="Untitled"></p> <p>以上三个函数都是失败return -1（fname不存在/index不合法/#inode不合法/inode中数据块索引不合法）。前两个函数成功都会将dentry指针赋值成所需要的那个directory数据，第三个函数相当于“read”这一system call，返回读取了多少个byte</p> <hr> <p><strong>**</strong><strong>**</strong>与Task的联动：<strong>**</strong><strong>**</strong></p> <p>每一个task最多开启8个file，它们被存在一个file array中，而file descriptor就是用来在array中找寻这些file的。file array中的每一个元素都应该储存以下四种信息</p> <ol> <li>对应这个file的各种操作函数，<strong>open, read, write, and close</strong> to perform type-specific actions for each operation.</li> <li>inode number，对于directory或者RTC就是0</li> <li>file position，指示用户在什么位置开启了这个file，由read system call更新</li> <li>flag，用来指示当前descriptor正在使用</li> </ol> <p><img src="Untitled12.png" alt="Untitled"></p> <p>open a file的流程：储存对应的jump table pointer，将flag设置成in-use</p> <hr> <h3 id="filesystem_init"> <strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>filesystem_init</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong> </h3> <ol> <li> <p>找到File img的开头地址，File的所有信息在boot的时候就已经帮我们储存在了内存的某一个地方</p> <p>根据文档，每一个img都算是一个module，可以load进去</p> <p><img src="Untitled.jpeg" alt="Untitled"></p> <p><img src="Untitled13.png" alt="Untitled"></p> </li> <li>在<code class="language-plaintext highlighter-rouge">kernel.c</code>里进行file system初始化，将上面找到的指针传递给file system</li> <li>传入的地址是boot_blcok的开头，直接将一个全局变量boot_block_ptr指向这个地方</li> <li>boot_block中的3个num信息，赋值给3个全局变量，用于储存有多少个directory，有多少个inode，有多少个data_block</li> <li>根据各个数字，找到inode的开头和data_block的开头，并将这两个地址储存在另外两个ptr中，以备后续使用</li> </ol> <p>tips：因为文件系统只读不写，可以用静态的全局变量储存这些所有信息</p> <hr> <h3 id="three-base-functions">Three base functions</h3> <p><strong>**read_dentry_by_index:</strong>**</p> <ol> <li>sanity check，如果index超出dir_num，return -1</li> <li>将boot_block中的<code class="language-plaintext highlighter-rouge">dentries[index]</code>值赋给传入的dentry指针 <ol> <li>赋值过程中，filename必须用<code class="language-plaintext highlighter-rouge">lib.c</code>提供的<code class="language-plaintext highlighter-rouge">strncpy</code>，因为filename允许没有string结尾符<code class="language-plaintext highlighter-rouge">\0</code> </li> </ol> </li> </ol> <p><strong>**read_dentry_by_name:</strong>**</p> <ol> <li>设置一个index变量，遍历所有在boot_block的file name，每次index++</li> <li>index++之后做check，如果已经超出dir_num，return -1</li> <li>如果匹配到（利用<code class="language-plaintext highlighter-rouge">lib.c</code>中提供的<code class="language-plaintext highlighter-rouge">strncmp</code>），呼叫<code class="language-plaintext highlighter-rouge">read_dentry_by_index(index, dentry)</code>，让read_dentry_by_index完成真正的赋值操作</li> </ol> <p><strong>**</strong><strong>**</strong><strong>**</strong><strong>read_data:</strong><strong>**</strong><strong>**</strong><strong>**</strong></p> <ol> <li>sanity check，确认(file总长度-offset)&gt;0 并且 inode_index &lt; boot_block拥有的inode数目-1</li> <li>找到对应的inode，<code class="language-plaintext highlighter-rouge">inodes_arr[i]</code> </li> <li>计算需要从哪个data_block的哪个位置开始读取 offset / block_size + offset % block_size</li> <li>计算读取到哪个data_block的哪个位置</li> <li>开始循环复制数据到buff中，同时要检测是否需要更换另一个data_block</li> </ol> <hr> <p>问题：我们需要在这里实现file descriptor array吗？暂时不需要，在之后的scheduler部分出现了task struct再实现</p> <hr> <h2 id="the-real-time-clock-driver">The Real-Time Clock Driver</h2> <p>reference:<a href="https://wiki.osdev.org/RTC" rel="external nofollow noopener" target="_blank">https://wiki.osdev.org/RTC</a></p> <p>做到和RTC交互，让user直接修改它的频率，最好能<strong>虚拟化</strong></p> <p>虚拟化可以采用一个全局变量counter，每次interrupt产生都++，这里的interrupt看做是一个基础interrupt，采取最高频率，即1024Hz</p> <p>对于不同频率，如果counter自这个read函数被创建后过了 1024/frequency次，则return</p> <p>例如：虚拟化的RTC_read需要一个512Hz的RTC，那么过了1024/512=2个interrupt后return</p> <p>可能需要一个array，全部entries初始化为1，对不同的虚拟的RTC device储存各自的频率，interrupt实际上只改变counter。在后续ckpt中，有多个terminal，每一个terminal上执行的程序可能会设置不同的RTC频率，对应这个array中的一个freq</p> <p><strong>open:</strong></p> <p>将freq改为2Hz，返回0。flag设置为0。后续到了多进程时，freq和flag都有多个，每个进程对应一对freq和flag。</p> <p><strong>close:</strong></p> <p>返回0（文档如此）</p> <p><strong>read:</strong></p> <p>跟踪全局flag，用一个while loop让read函数陷入循环，直到flag被设置成1，跳出循环。跳出时再重新将flag设置为0，return。这样可以达到一种类似于linux中sleep的效果。</p> <p><strong>**</strong><strong>**</strong>write:<strong>**</strong><strong>**</strong></p> <p>先做sanity check，如果都通过，根据传入的frequency设置freq。此时暂时只有一个terminal，没有进程之间的切换，在后续ckpt中需要检查当前write指令是由哪一个进程调用的，修改这个进程对应的freq</p> <p><strong>handler:</strong></p> <p>使counter++，检查是否度过了freq个单位时间，如果是，将flag设置为1。设置为1的时候，之前某次调用的read函数就会返回。</p> <p>具体相关端口，对rtc的交互请查看reference（OSdev）</p> <hr> <h1 id="checkpoint-3">Checkpoint 3</h1> <h2 id="system-calls">System Calls</h2> <p>int $0x80呼叫，最多接受三个参数</p> <p>call number, arg1, arg2, arg3 → EAX, EBX, ECX, EDX</p> <p>成功return 0，失败return -1，返回值放在EAX</p> <p>一部分不会返回（如halt）</p> <p><strong>open</strong></p> <p>在文件系统中找到文件，分配一个空闲的描述符并初始化（注意文件类型）</p> <p><strong>close</strong></p> <p>检测描述符合法性，后释放描述符</p> <p><strong>read</strong></p> <p>从RTC/键盘/文件/目录读取数据，返回读取的bytes数量</p> <p>RTC：接收到virtual interrupt时返回0</p> <p>键盘：读取到\n时 或 buffer满时返回</p> <p>文件：读取到EOF时 或 buffer满时返回</p> <p>File Position指读取位置</p> <p>system call的传入参数性质也决定了我们需要为它们编写一个wrapper(link)来保证参数正常传递</p> <hr> <h3 id="wrapper--linkage">Wrapper &amp; Linkage</h3> <p>需要实现的10个system call最多只有三个参数，用asm写wrapper <strong>（这部分并不归我们写，提供的可执行文件包含了这部分wrapper）</strong></p> <p>在IDT的0x80号位置调用包装函数</p> <ol> <li>callee saved</li> <li>获取arguments，根据数目不同从EBX, ECX, EDX中获取</li> <li>获取system call number，<code class="language-plaintext highlighter-rouge">int 0x80</code> </li> <li>restore callee saved</li> </ol> <hr> <h3 id="system-call-handler">System call handler</h3> <ol> <li>save all registers</li> <li>check system call number is valid or not</li> <li> <p>利用已有的function table找到对应system call，从call之后的stack来看，获取参数应该在每一个system call所对应的函数之内 — 问题：如何让一个C function直接从寄存器中读取数值，fastcall？</p> <p>或者<strong>另一种解决办法，直接在system call handler中恢复C convention</strong></p> <p><img src="Untitled14.png" alt="Untitled"></p> </li> <li>检查返回值，失败与成功</li> <li>restore register</li> <li>重新设置关于iret所需要的一切</li> <li>iret</li> </ol> <hr> <h3 id="execute-sys-call具体流程">Execute sys call具体流程</h3> <p>尝试加载一个新的程序</p> <p>接收参数command（字符串）是一个以空格为分界的一连串words，第一个word是file name，之后的都由getargs获得</p> <p>无法执行（命令不存在、非可执行文件）返回-1，Exception返回256，halt返回0~255的值</p> <p><strong>Parse args</strong></p> <p>对于<strong>file name</strong>，直接取出第一个空格之前的所有内容即可，写一个loop，直到char == ’ ’停止</p> <p>其他的arguments暂时好像用不到</p> <p><strong>Check file validity</strong></p> <ol> <li>利用file name检查file中是否存在一样的文件，在这里利用<strong>read_dentry_by_name</strong>时可以把信息存在一个dentry变量中，接下来需要使用</li> <li>再读取这个file的前4个bytes（<strong>read_data</strong>)，查看它是否是一个可执行文件</li> <li>在这里也可以直接获取program第一条指令执行的位置（<strong>read_data</strong>），储存在可执行文件的24-27bytes</li> </ol> <p><strong>Create PCBs</strong></p> <p>寻找到pid，当前是第几个process</p> <p>为PCB分配空间，初始化，设置为active，其中kernel stack根据不同的pid有不同的值</p> <p>Open File descriptor for stdin/stdout</p> <p><strong>Set up paging</strong></p> <p>需要知道当前是第几个process，我们应该可以假设最多只有3个process（像PPT上一样）</p> <p>直接在Page Directory中 ( 0x8000000(128MB) »22 )，即2^5=<strong>32位置修改映射</strong></p> <p><strong>phy add = 0x800000 + pid*4MB</strong> 将 PD[32]对应的4MB page起始点修改为 <strong>phy add »12</strong>即可</p> <p>记得flush tlb，即重新载入一遍cr3</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 *   set_user_prog_page
 *   Set page for a user program
 *   input: pid -- the pid of the user program
 *   output: None
 *   side effect: Change the paging directory; Change CR3; flush TLB
 */</span>
</code></pre></div></div> <p><strong>Load file(program) into memory</strong></p> <p>file的起始点为USER_CODE 0x8048000</p> <p><strong>Prepare for context switch</strong></p> <p>mp3 system中只有一个tss，就是在<code class="language-plaintext highlighter-rouge">x86_desc.h</code>中的tss变量，在回到user level之前，tss中的相关参数需要被更新</p> <p>不需要考虑schedule的情况下，只需要更改tss的值即可，在soft multitasking中，tss只有两个值是相关的，<strong>更改SS0为kernel ds，ESP0为当前process的stack，即8MB-8KB*(pid)-1个byte、</strong></p> <aside> ➡️ esp0永远是8MB-8KB*(pid)-1，是因为每次从kernel回到user space，kernel stack都被“清空”，stack上实际的数据没有改变，但下一次回到kernel space，从栈底开始。这样做的原因是防止kernel stack overflow </aside> <p><img src="Untitled15.png" alt="Untitled"></p> <p>iret需要的五个参数：</p> <ul> <li>user ds，直接用x86_desc.h中的user ds；</li> <li>esp，user stack，位于128MB-132MB这一段memory的末尾，即132MB-4byte；</li> <li>eflag，直接把当前的flag push进去可行吗？</li> <li>cs，tss中的user cs；</li> <li>eip，把上面储存的user program第一条指令对应的地址拿过来</li> </ul> <hr> <h3 id="halt-sys-call具体流">Halt sys call具体流</h3> <p>终止进程并返回母进程</p> <p>Shell —”execute” syscall (when cmd is typed)→ Program</p> <p>Program —”halt” syscall (when “return”)→ Shell</p> <p>很重要的一点，如果我们要检测是否exception，需要在原来的exception while1改成呼叫halt的函数</p> <p>halt的总体思想，利用parent process在kernel stack上存好的context来iret，以此回到parent process的user level</p> <ol> <li>首先check这是否是exception呼叫的</li> <li>再看一下是否是shell，如果是shell本身出问题，需要重启shell，因为它是第一个program，不能被完全杀死</li> <li>关闭file descriptor，将开启了的file均关闭，因为如果不关闭，之后重新利用这段pcb的时候会发现许多file都是“开启”状态</li> <li>将当前的process设置为non-active</li> <li>找到parent，并从parent的pcb中取出信息，将paging设置为parent program所需要的</li> <li>将tss更新成parent的信息，SS0=kernel ds，ESP0=parent kernel stack</li> <li>再从parent pcb中找到之前的context信息，具体而言，是从parent pcb中重新取回之前的ebp和esp，之后再leave+ret就相当于从execute这个syscall的地方返回，直接用这些context信息来进行iret</li> </ol> <hr> <h2 id="tasks">Tasks</h2> <p>此次不用完成scheduler，但需要在某一个program产生exception时回到shell</p> <p>所有tasks共享一个4MB内核态分页。对于一个而言，其task映像（代码）的物理地址是固定的而且每个小于4MB，分配一个用户态分页即可。</p> <hr> <h2 id="loader">Loader</h2> <p>在文件系统驱动中，将程序代码从随机分配&amp;排列（也即分散）的4kB disk blocks拷贝到连续的物理地址中</p> <p>注意维护栈，拷贝在内核态执行，拷贝结束后要回到用户态</p> <hr> <h2 id="executing-user-level-code">Executing User-level Code</h2> <p>注意内核态程序不能调用用户态程序，要实现privilege switch</p> <p>IRET的正常运行要求提供ESP EIP EFLAGS CS SS等寄存器值</p> <p>EIP → 位于可执行文件24~27B的entry point</p> <p>ESP → 载入可执行文件的4MB分页末尾</p> <p>CS → user code segment</p> <p>DS → user data segment</p> <p>SS → user stack segment （有声明吗？）</p> <p>而且需改变TSS</p> <hr> <h2 id="process-control-block">Process Control Block</h2> <p>需储存的Per-Task State包括</p> <p>File array（记录开启的文件）</p> <p>Signal information → extra credit内容，可以不识闲</p> <p>Kernel stack（每个8kB）</p> <p>两个task的kernel stack分别占用第4080~4087、4088~4095kB</p> <p>parent pid</p> <p>excute_ebp / excute_esp 用于halt</p> <hr> <h1 id="checkpoint-4">Checkpoint 4</h1> <h2 id="getargs">getargs</h2> <p>在execute内调用</p> <p>参数（以字符串的形式）存储在PCB，裁剪（头部）可执行文件名&amp;空格、（尾部）空格</p> <p>例：在Shell #0中运行” cat arg1 arg2 “，将”arg1 arg2”存入PCB #1（注意空格数量）</p> <h3 id="步骤">步骤</h3> <p>在buf中传入用户输入的命令</p> <p>检测头部空格结束的位置、尾部空格开始的位置</p> <p>将两个位置之间的args字符串拷贝进PCB（args之间可以有任意数量空格，交给user program处理）</p> <p>成功返回0，失败（args<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**+NULL</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>**太大/检测不到args）返回-1</p> <p>最好把PCB #0（shell）的args字符串设置为”\0”</p> <h2 id="vidmap">vidmap</h2> <p>需要DPL = 0以访问物理内存vmem，影响安全性。解决方案为将vmem映射到虚拟内存</p> <p>*screen_start指向虚拟内存地址（用户给定）</p> <p>双重指针的作用是允许访问整个新的4kB page</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// implimentation</span>
<span class="kt">uint8_t</span><span class="o">*</span> <span class="n">screen_start</span> <span class="o">=</span> <span class="n">vidmap</span><span class="p">();</span>
<span class="c1">// or</span>
<span class="n">uint_t</span><span class="o">*</span> <span class="n">screen_start</span><span class="p">;</span>
<span class="n">vidmap</span><span class="p">(</span><span class="n">screen_start</span><span class="p">);</span>
</code></pre></div></div> <h3 id="步骤-1">步骤</h3> <p>检查*screen_start的合法性：应大于128MB，小于132MB（？）</p> <p>修改PD和PT实现mapping，将DPL设置为3供用户访问（？）</p> <p>成功返回<strong>0xB8000</strong>，失败返回-1</p> <hr> <h1 id="checkpoint-5">Checkpoint 5</h1> <h2 id="multiple-terminals">Multiple Terminals</h2> <p>3个terminal，最多同时运行6个程序</p> <h3 id="initialization">Initialization</h3> <ul> <li>Initial bootup: 在系统启动时就初始化三个进程</li> <li>After bootup: 用Alt+F1/F2/F3切换，当用户第一次按下ALT+F2/F3时开启新的terminal</li> </ul> <h3 id="separate-io-buffer">Separate I/O buffer</h3> <p>每一个terminal结构体中存储独立的I/O buffer、光标、显示屏上的文字、active flag</p> <p>在切换出terminal的时候存起来，切换回来的时候重新载入</p> <h3 id="isolation">Isolation</h3> <p>退出某一个terminal的shell时，不会立即重启，直到把最后一个shell也退出时才需要重启shell</p> <p>在halt修改一下重启条件，判断是否是最后一个shell</p> <h3 id="switch">Switch</h3> <p><img src="Untitled16.png" alt="multi terminal 内存示意图"></p> <p>multi terminal 内存示意图</p> <p>需要新分配三块backup video memory，类似build buffer的作用，每一块都储存着当前terminal的video memory，在切换的时候进行载入</p> <h3 id="步骤-2">步骤</h3> <p>在<code class="language-plaintext highlighter-rouge">terminal.c</code>中定义<code class="language-plaintext highlighter-rouge">void switch_terminal(uint8_t term_index)</code>函数，在<code class="language-plaintext highlighter-rouge">keyboard.c</code>中调用</p> <ol> <li>Sanity check，传入index是否越界</li> <li>判断term_index是否为当前current_term_index（全局变量），若是则直接返回</li> <li>切换流程(以从terminal1切换到terminal2为例子) <ol> <li>video map到current terminal，即让0xB8000指向phyiscal的0xB8000</li> <li>将当前vmem存到属于terminal1的backup内存块（term1 video page）中</li> <li>将terminal2的backup内存块载入vmem</li> <li>设置光标位置，此时屏幕更新完成</li> <li>更新全局变量current_term_id</li> <li>video map到当前正在schedule的process</li> </ol> </li> </ol> <p>tips: video map指的是更新virtual 0xB8000指向的physical memory映射关系，以下为函数的描述</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*   remap_vidmap_page
 *   Set page for video memory for a specific terminal.
 *   If terminal_id = active one, directly write into physical memory.
 *   If terminal_id != active one, map user video memory to corresponding backup buffer.
 *   input: screen_start -- starting address of the video memory
 *   output: None
 *   side effect: Change the paging directory; Change CR3; flush TLB */</span>
</code></pre></div></div> <hr> <h2 id="scheduling">Scheduling</h2> <p>跟踪所有活跃的task，每隔10-50ms轮流切换执行</p> <p>被暂停的task不应该打印信息，需要动态更新page table以将显示映射到0xB8000以外的地方</p> <h3 id="pit">PIT</h3> <p>reference: <a href="https://wiki.osdev.org/PIT" rel="external nofollow noopener" target="_blank">OSDEV Link for PIT</a></p> <p>Scheduling中计时使用PIT而非RTC，因为RTC的优先级太低了</p> <p>在PIT发生一次interrupt时调用handler（在IDT中注册），在handler中进行一次schedule操作</p> <p>使用Chanel0作为I/O Port <code class="language-plaintext highlighter-rouge">0x40 Channel 0 data port (read/write)</code></p> <p>向0x43 port写入选择的channel，mode</p> <h3 id="scheduler">Scheduler</h3> <p>在进行具体流程之前，必须明确一个事实。一个不是正在执行的process的stack上，<strong>必然是scheduler的残留信息</strong>，因为process只要开始执行，只有两种可能退出当前stack：</p> <ol> <li>执行完毕，返回user space</li> <li>还未执行完毕，但是被scheduler强制退出，去往其他process</li> </ol> <p>所以只要我们发现可以找到next process，那这个process一定是属于2情况，即stack上残留了上一次scheduler未return的所有信息，在接下来的task switch中，以为switch的时候依然使用的是scheduler的代码，直接更改esp、ebp即可</p> <p><img src="Untitled17.png" alt="Untitled"></p> <h3 id="步骤-3">步骤</h3> <p><strong>核心思想1：scheduler通过更改esp, ebp实现在kernel stack之间的切换</strong></p> <ol> <li>PIT产生interrupt，在其<code class="language-plaintext highlighter-rouge">pit_handler</code>中呼叫<code class="language-plaintext highlighter-rouge">scheduler_linkage (asm)</code> </li> <li>进入scheduler后，先<strong>储存本次scheduler进入时的ebp</strong>，储存到<code class="language-plaintext highlighter-rouge">pcb→sch_ebp</code>中</li> <li>找到在schedule array中的下一个需要被schedule的process，以下称为<strong><code class="language-plaintext highlighter-rouge">next process</code></strong>，并更新<code class="language-plaintext highlighter-rouge">cur_sch_index</code>（用来指示当前schedule是哪个process的变量）</li> <li>若next process的pid为-2(TERM_NOT_INIT宏)，代表下一个terminal上还没有被初始化任何进程 <ol> <li> <code class="language-plaintext highlighter-rouge">remap_video_page(cur_sch_index)</code> 接下来的一切和video相关操作会作用在即将新开启的shell process上</li> <li>执行<code class="language-plaintext highlighter-rouge">execute('shell')</code> </li> </ol> <aside> ➡️ 这样做可以解决刚开始三个process的kernel stack上都没有scheduler残余的问题。三个空的kernel stack会一个个被初始化成为有scheduler残余的kernel stack </aside> </li> <li> <p>如果下一个terminal已经有进程可以被schedule了：为进入user space做准备，对user program的map进行调整，即对program image进行更改</p> <p>将user program部分指向physical memory中next process的program image。和execute使用一个更改user program paging的函数</p> <div class="language-c highlighter-rouge"> <div class="highlight"><pre class="highlight"><code> <span class="cm">/*   set_user_prog_page
  *   Set page for a user program
  *   input: pid -- the pid of the user program
  *   output: None
  *   side effect: Change the paging directory; Change CR3; flush TLB */</span>
</code></pre></div> </div> </li> <li>改变TSS，为回到kernel space做准备</li> <li>remap user video memory</li> <li> <p>准备context switch到即将切换到的process</p> <p>不能直接使用iret，而是<strong>重新载入另一个process的ebp</strong>，只是相当于换了一个kernel stack</p> <ol> <li>在scheduler中，将next process <code class="language-plaintext highlighter-rouge">pcb→ sch_ebp</code>取出来，这个ebp储存的是上一次从刚刚进入scheduler时的stack state</li> <li>将这个pcb→sch_ebp赋值给ebp，再leave+ret，实际上是从next process kernel stack上回到了pit handler</li> </ol> </li> <li>在切换stack之后，回到了PIT handler，PIT handler再return，则可以利用PIT lnk(asm)中的iret，可以switch到next process的user space</li> </ol> <hr> <p><img src="Untitled18.png" alt="Untitled"></p> <p>virtual的0xB8000指向scheduled process的backup buffer，如果和display terminal是一个，则指向physical的0xB8000</p> <p>键盘的字符永远要输入到physical的0xB8000</p> <h3 id="video-memory-problems">Video memory problems</h3> <p>上述实现逻辑会造成video memory出现一定的错乱问题，需要对<code class="language-plaintext highlighter-rouge">lib.c</code>中的<code class="language-plaintext highlighter-rouge">putc</code>函数进行一定的更改</p> <p>keyboard interrupt呼叫putc，默认朝0xB8000进行输入。但在schedule过程中，0xB8000因为video_remap的原因，未必时刻指向真实的video memory，可能指向backup buffer。但实际上，keyboard的输入应该显示在当前展示的terminal上，而非当前scheduled的terminal上。</p> <p>而terminal_write中呼叫的putc，则需要显示在当前scheduled的terminal上，而非当前展示的terminal，这与keyboard逻辑有所不同</p> <p>在已经提供的许多user program中，大多数向屏幕上打印的方法是呼叫terminal_write，而<code class="language-plaintext highlighter-rouge">fish.c</code>是使用<code class="language-plaintext highlighter-rouge">vidmap</code>直接获取地址然后修改值</p> <p>这一部分比较繁琐细碎，但并不困难，这个笔记里不过多赘述。</p> <hr> <h1 id="extra-credit">Extra Credit</h1> <h2 id="memory-allocation">Memory Allocation</h2> <p>Two types of memory management</p> <ol> <li>Fixed length memory allocation</li> <li>Varaible length memory allocation</li> </ol> <h3 id="fixed-length--slab-cache">Fixed length — Slab Cache</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">In</span> <span class="n">this</span> <span class="n">specific</span> <span class="n">implementation</span><span class="p">,</span> <span class="n">fixed</span> <span class="n">length</span> <span class="n">memory</span> <span class="n">allocation</span> <span class="n">is</span> <span class="n">implemented</span> <span class="n">by</span> <span class="n">two</span> <span class="n">parts</span><span class="p">,</span> <span class="n">memory</span> <span class="n">management</span> <span class="n">unit</span> <span class="n">and</span> <span class="n">memory</span> <span class="n">unit</span><span class="p">.</span>
<span class="n">fixed</span> <span class="n">length</span> <span class="n">diagram</span><span class="o">:</span>
        <span class="o">|</span><span class="n">memory</span> <span class="n">management</span> <span class="n">unit</span><span class="o">|</span>  <span class="o">|</span><span class="n">memory</span> <span class="n">management</span> <span class="n">unit</span><span class="o">|</span>  <span class="o">|</span><span class="n">memory</span> <span class="n">management</span> <span class="n">unit</span><span class="o">|</span>  <span class="p">..........</span>    <span class="o">|</span><span class="n">memory</span> <span class="n">unit</span><span class="o">|</span>  <span class="o">|</span><span class="n">memory</span> <span class="n">unit</span><span class="o">|</span> <span class="o">|</span><span class="n">memory</span> <span class="n">unit</span><span class="o">|</span> <span class="p">.....</span>
        <span class="o">|</span><span class="n">next</span><span class="o">|</span>  <span class="o">---------------&gt;</span>  <span class="o">|</span><span class="n">next</span><span class="o">|</span>  <span class="o">---------------&gt;</span>  <span class="o">|</span><span class="n">next</span><span class="o">|</span>                                      <span class="err">↑</span>              <span class="err">↑</span>             <span class="err">↑</span>
        <span class="o">|</span><span class="n">ptr</span><span class="o">|---------------------|</span><span class="n">ptr</span><span class="o">|---------------------|</span><span class="n">ptr</span><span class="o">|---------------------------------------</span><span class="err">↑</span><span class="o">--------------</span><span class="err">↑</span><span class="o">-------------</span><span class="err">↑</span>
</code></pre></div></div> <p>Data structure: Linked list</p> <ul> <li>Slab_Create ( name , size )</li> <li>destroy , malloc , free</li> <li>Automatically shrinks and grows</li> <li>quick and fast to allocate and free</li> <li>granularity: 1byte - 4kB-8 bytes</li> </ul> <h3 id="variable-length--implicit-free-list">Variable length — Implicit free list</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">On</span> <span class="n">the</span> <span class="n">other</span> <span class="n">hand</span><span class="p">,</span> <span class="n">variable</span> <span class="n">length</span> <span class="n">memory</span> <span class="n">allocation</span> <span class="n">is</span> <span class="n">implemented</span> <span class="n">very</span> <span class="n">similar</span> <span class="n">to</span> <span class="n">Linux</span><span class="err">'</span><span class="n">s</span> <span class="n">implicit</span> <span class="n">free</span> <span class="n">list</span> <span class="n">design</span><span class="p">.</span> 
<span class="n">A</span> <span class="n">memory</span> <span class="n">part</span> <span class="n">consists</span> <span class="n">of</span> <span class="n">two</span> <span class="n">parts</span><span class="p">,</span> <span class="n">memory</span> <span class="n">management</span> <span class="n">unit</span> <span class="n">and</span> <span class="n">real</span> <span class="n">useable</span> <span class="n">memory</span> <span class="n">unit</span><span class="p">.</span>
<span class="n">Memory</span> <span class="n">management</span> <span class="n">units</span> <span class="n">are</span> <span class="n">held</span> <span class="n">in</span> <span class="n">a</span> <span class="n">linked</span> <span class="n">list</span> <span class="n">to</span> <span class="n">track</span> <span class="n">each</span> <span class="n">memory</span> <span class="n">fragments</span> <span class="n">have</span> <span class="n">been</span> <span class="n">allocated</span><span class="p">.</span>
<span class="n">variable</span> <span class="n">length</span> <span class="n">diagram</span><span class="o">:</span>
        <span class="o">|</span><span class="n">memory</span> <span class="n">mangement</span> <span class="n">unit</span><span class="o">|</span> <span class="o">-&gt;</span> <span class="o">|</span><span class="n">memory</span> <span class="n">mangement</span> <span class="n">unit</span><span class="o">|</span> <span class="o">-&gt;</span> <span class="o">|</span><span class="n">memory</span> <span class="n">mangement</span> <span class="n">unit</span><span class="o">|</span> <span class="o">-&gt;</span> <span class="o">|</span><span class="n">memory</span> <span class="n">mangement</span> <span class="n">unit</span><span class="o">|</span>
        <span class="o">-----------------------</span>    <span class="o">-----------------------</span>    <span class="o">-----------------------</span>    <span class="o">-----------------------</span>
        <span class="o">|</span>                     <span class="o">|</span>    <span class="o">|</span>                     <span class="o">|</span>    <span class="o">|</span>                     <span class="o">|</span>    <span class="o">|</span>                     <span class="o">|</span>
        <span class="o">|</span>   <span class="n">useable</span> <span class="n">memory</span>    <span class="o">|</span>    <span class="o">|</span>   <span class="n">useable</span> <span class="n">memory</span>    <span class="o">|</span>    <span class="o">|</span>   <span class="n">useable</span> <span class="n">memory</span>    <span class="o">|</span>    <span class="o">|</span>   <span class="n">useable</span> <span class="n">memory</span>    <span class="o">|</span>
        <span class="o">|</span>                     <span class="o">|</span>    <span class="o">|</span>                     <span class="o">|</span>    <span class="o">-----------------------</span>    <span class="o">|</span>                     <span class="o">|</span>
        <span class="o">|</span>                     <span class="o">|</span>    <span class="o">-----------------------</span>                               <span class="o">-----------------------</span>
        <span class="o">|</span>                     <span class="o">|</span>
        <span class="o">-----------------------</span>

<span class="n">Slab</span> <span class="n">cache</span><span class="err">'</span><span class="n">s</span> <span class="n">implementation</span> <span class="n">is</span> <span class="n">based</span> <span class="n">on</span> <span class="n">fixed</span> <span class="n">length</span> <span class="n">memory</span> <span class="n">allocation</span><span class="p">.</span>
</code></pre></div></div> <p>Data structure: Implicit free list</p> <ul> <li>varmalloc( size )</li> <li>flexible: can allocate any size</li> <li>granularity: 1byte - 4MB</li> </ul> <h2 id="signal">Signal</h2> <p>Support users to set handler they define</p> <p>Support sigreturn and set_handler syscall</p> <p>Support five signals:</p> <ol> <li>SIG_DIV_ZERO</li> <li>SIG_SEGFAULT</li> <li>SIG_INTERRUPT</li> <li>SIG_ALARM</li> <li>SIG_USER1</li> </ol> <h2 id="ata-hard-disk-support--file-system">ATA Hard Disk Support &amp; File System</h2> <ul> <li> <p>Writable file system</p> <div class="language-jsx highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>  <span class="nx">write</span> <span class="nx">fname</span> <span class="nx">contents</span>
</code></pre></div> </div> </li> <li>Persistent Change (after reboot) by saving the change to the hard drive</li> <li>How the file system is loaded and initialized:</li> </ul> <p><img src="Untitled19.png" alt="Untitled"></p> <h2 id="speaker-driver">Speaker Driver</h2> <p>Toggle <strong>**</strong><strong>**</strong><strong>NumLock</strong><strong>**</strong><strong>**</strong> to turn on/off</p> <p>Key mapping:</p> <p>(C3~E4) ZSXDCVGBHNJM,L.;/</p> <p>(C4~G5) Q2W3ER5T6Y7UI9O0P[=]</p> <p>Runs concurrently with any user programs &amp; across terminals</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2022/displaying-external-posts-on-your-al-folio-blog/">Displaying External Posts on Your al-folio Blog</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/custom-blockquotes/">a post with custom blockquotes</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/sidebar-table-of-contents/">a post with table of contents on a sidebar</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/audios/">a post with audios</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/videos/">a post with videos</a> </li> <div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"alshedivat/al-folio","data-repo-id":"MDEwOlJlcG9zaXRvcnk2MDAyNDM2NQ==","data-category":"Comments","data-category-id":"DIC_kwDOA5PmLc4CTBt6","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,a])=>giscusScript.setAttribute(t,a)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Zicheng Ma. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js"></script> <script defer src="/assets/js/common.js"></script> <script defer src="/assets/js/copy_code.js" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>