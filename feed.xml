<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://zichengma.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://zichengma.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-09-15T01:42:05+00:00</updated><id>https://zichengma.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">k8s operator practice</title><link href="https://zichengma.github.io/blog/2023/k8s-operator-practice/" rel="alternate" type="text/html" title="k8s operator practice"/><published>2023-03-26T20:28:15+00:00</published><updated>2023-03-26T20:28:15+00:00</updated><id>https://zichengma.github.io/blog/2023/k8s-operator-practice</id><content type="html" xml:base="https://zichengma.github.io/blog/2023/k8s-operator-practice/"><![CDATA[<p>I am learning how to write Kubernetes operator these days. This post is used to record some basic definition and a very good sample controller implemented by <a href="http://workshop.coreostrain.me/lab/go-operator/podset/">RedHat</a>.</p> <h3 id="introduction-to-kubernetes-operators">Introduction to Kubernetes Operators</h3> <p>Kubernetes is a powerful platform for managing containerized applications at scale. While Kubernetes provides a robust set of primitives for deploying and managing applications, it can be challenging to build and manage complex applications using only these primitives. This is where Kubernetes Operators come in.</p> <p>An Operator is a method of packaging, deploying, and managing a Kubernetes application. Operators use custom resources, controllers, and reconciliation loops to automate the deployment and management of complex applications on Kubernetes. In this article, we will explore the concept of Operators in Kubernetes and dive into the details of building an Operator using Go.</p> <h3 id="reconciler-overview">Reconciler Overview</h3> <p>One of the key components of a Kubernetes Operator is the reconciler. The reconciler is responsible for comparing the desired state of a Kubernetes resource with its current state and taking actions to reconcile any differences between the two.</p> <p>In Go-based Kubernetes Operators, the reconciler is typically implemented as a controller. The controller watches for changes to a specific type of Kubernetes resource, and when a change is detected, it initiates a reconciliation loop. During the reconciliation loop, the controller retrieves the current state of the resource from the Kubernetes API server, compares it with the desired state, and takes actions to reconcile any differences.</p> <h3 id="code-analysis">Code analysis</h3> <p>The CRDs we defined is PodSet. Spec: Replicas(How many pods we want) Status: ReadyReplicas(The number of ready replicas) PodNames(A slice for all ready replicas name) Controller will try to update Status.ReadyReplicas = Spec.Replicas and up/down scaling pods based on the difference.</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/</span>

<span class="k">package</span> <span class="n">controllers</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"context"</span>
	<span class="s">"reflect"</span>

	<span class="n">corev1</span> <span class="s">"k8s.io/api/core/v1"</span>
	<span class="s">"k8s.io/apimachinery/pkg/api/errors"</span>
	<span class="n">metav1</span> <span class="s">"k8s.io/apimachinery/pkg/apis/meta/v1"</span>
	<span class="s">"k8s.io/apimachinery/pkg/labels"</span>
	<span class="s">"k8s.io/apimachinery/pkg/runtime"</span>
	<span class="n">ctrl</span> <span class="s">"sigs.k8s.io/controller-runtime"</span>
	<span class="s">"sigs.k8s.io/controller-runtime/pkg/client"</span>
	<span class="s">"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"</span>
	<span class="s">"sigs.k8s.io/controller-runtime/pkg/log"</span>

	<span class="n">batchv1</span> <span class="s">"tutorial.kubebuilder.io/operator-practice/api/v1"</span>
<span class="p">)</span>

<span class="c">// PodSetReconciler reconciles a PodSet object</span>
<span class="k">type</span> <span class="n">PodSetReconciler</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">client</span><span class="o">.</span><span class="n">Client</span>
	<span class="n">Scheme</span> <span class="o">*</span><span class="n">runtime</span><span class="o">.</span><span class="n">Scheme</span>
<span class="p">}</span>

<span class="c">//+kubebuilder:rbac:groups=batch.tutorial.kubebuilder.io,resources=podsets,verbs=get;list;watch;create;update;patch;delete</span>
<span class="c">//+kubebuilder:rbac:groups=batch.tutorial.kubebuilder.io,resources=podsets/status,verbs=get;update;patch</span>
<span class="c">//+kubebuilder:rbac:groups=batch.tutorial.kubebuilder.io,resources=podsets/finalizers,verbs=update</span>

<span class="c">// Reconcile is part of the main kubernetes reconciliation loop which aims to</span>
<span class="c">// move the current state of the cluster closer to the desired state.</span>
<span class="c">// TODO(user): Modify the Reconcile function to compare the state specified by</span>
<span class="c">// the PodSet object against the actual cluster state, and then</span>
<span class="c">// perform operations to make the cluster state reflect the state specified by</span>
<span class="c">// the user.</span>
<span class="c">//</span>
<span class="c">// For more details, check Reconcile and its Result here:</span>
<span class="c">// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.14.1/pkg/reconcile</span>
<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span><span class="n">PodSetReconciler</span><span class="p">)</span> <span class="n">Reconcile</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="n">req</span> <span class="n">ctrl</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">(</span><span class="n">ctrl</span><span class="o">.</span><span class="n">Result</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">log</span> <span class="o">:=</span> <span class="n">log</span><span class="o">.</span><span class="n">FromContext</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>

	<span class="c">// TODO(user): your logic here</span>

	<span class="c">// listen to the creation of PodSet objects</span>

	<span class="c">// fetch the PodSet object</span>
	<span class="n">podset</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">batchv1</span><span class="o">.</span><span class="n">PodSet</span><span class="p">{}</span>
	<span class="n">err</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">TODO</span><span class="p">(),</span> <span class="n">req</span><span class="o">.</span><span class="n">NamespacedName</span><span class="p">,</span> <span class="n">podset</span><span class="p">)</span> <span class="c">// get the PodSet object from the API server by its name and namespace and store it in the podset variable</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">errors</span><span class="o">.</span><span class="n">IsNotFound</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="c">// Request object not found, could have been deleted after reconcile request.</span>
			<span class="c">// Owned objects are automatically garbage collected. For additional cleanup logic use finalizers.</span>
			<span class="c">// Return and don't requeue</span>
			<span class="k">return</span> <span class="n">ctrl</span><span class="o">.</span><span class="n">Result</span><span class="p">{},</span> <span class="no">nil</span>
		<span class="p">}</span>
		<span class="c">// Error reading the object - requeue the request.</span>
		<span class="c">// If the error is not a NotFound error, the second if statement is triggered, and the controller</span>
		<span class="c">// returns a ctrl.Result{} along with the original error to requeue the request for reconciliation.</span>
		<span class="c">// This is done to allow the controller to retry the operation at a later time, in case the error was temporary or transient.</span>
		<span class="k">return</span> <span class="n">ctrl</span><span class="o">.</span><span class="n">Result</span><span class="p">{},</span> <span class="n">err</span>
	<span class="p">}</span>

	<span class="n">podList</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">corev1</span><span class="o">.</span><span class="n">PodList</span><span class="p">{}</span> <span class="c">// create a new list of pods not podsets!</span>
	<span class="c">// The lbs variable is a map of labels that will be used to filter the list of pods. In this case, the labels are set to app=podset.Name and version=v0.1.</span>
	<span class="c">// This means that the query will only return pods that have the app label set to the name of the podset object and the version label set to v0.1.</span>
	<span class="n">lbs</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
		<span class="s">"app"</span><span class="o">:</span>     <span class="n">podset</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span>
		<span class="s">"version"</span><span class="o">:</span> <span class="s">"v0.1"</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="n">labelSelector</span> <span class="o">:=</span> <span class="n">labels</span><span class="o">.</span><span class="n">SelectorFromSet</span><span class="p">(</span><span class="n">lbs</span><span class="p">)</span> <span class="c">// create a label selector from the lbs map</span>
	<span class="c">// the listOps variable is a client.ListOptions object that contains the options for querying the Kubernetes API server.</span>
	<span class="n">listOps</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">client</span><span class="o">.</span><span class="n">ListOptions</span><span class="p">{</span><span class="n">Namespace</span><span class="o">:</span> <span class="n">podset</span><span class="o">.</span><span class="n">Namespace</span><span class="p">,</span> <span class="n">LabelSelector</span><span class="o">:</span> <span class="n">labelSelector</span><span class="p">}</span> <span class="c">// create a list options object with the namespace and label selector</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">TODO</span><span class="p">(),</span> <span class="n">podList</span><span class="p">,</span> <span class="n">listOps</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ctrl</span><span class="o">.</span><span class="n">Result</span><span class="p">{},</span> <span class="n">err</span>
	<span class="p">}</span>

	<span class="c">// Count the pods that are pending or running as available</span>
	<span class="k">var</span> <span class="n">available</span> <span class="p">[]</span><span class="n">corev1</span><span class="o">.</span><span class="n">Pod</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">pod</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">podList</span><span class="o">.</span><span class="n">Items</span> <span class="p">{</span>
		<span class="c">// For each pod, it first checks whether the DeletionTimestamp field is set.</span>
		<span class="c">// If it is, this means that the pod is scheduled for deletion, and the code skips it</span>
		<span class="k">if</span> <span class="n">pod</span><span class="o">.</span><span class="n">ObjectMeta</span><span class="o">.</span><span class="n">DeletionTimestamp</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="c">// If the pod is not scheduled for deletion, then check whether the pod's Status.Phase field is set to either corev1.PodRunning or corev1.PodPending.</span>
		<span class="c">// If the pod is in one of these states, it is considered available, and its reference is added to the available slice.</span>
		<span class="k">if</span> <span class="n">pod</span><span class="o">.</span><span class="n">Status</span><span class="o">.</span><span class="n">Phase</span> <span class="o">==</span> <span class="n">corev1</span><span class="o">.</span><span class="n">PodRunning</span> <span class="o">||</span> <span class="n">pod</span><span class="o">.</span><span class="n">Status</span><span class="o">.</span><span class="n">Phase</span> <span class="o">==</span> <span class="n">corev1</span><span class="o">.</span><span class="n">PodPending</span> <span class="p">{</span>
			<span class="n">available</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">available</span><span class="p">,</span> <span class="n">pod</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">numAvailable</span> <span class="o">:=</span> <span class="kt">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">available</span><span class="p">))</span> <span class="c">// get the number of available pods</span>

	<span class="c">// This code block creates a new slice of strings called availableNames,</span>
	<span class="c">// which contains the names of all the available pods returned by the previous code block.</span>
	<span class="n">availableNames</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">pod</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">available</span> <span class="p">{</span>
		<span class="n">availableNames</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">availableNames</span><span class="p">,</span> <span class="n">pod</span><span class="o">.</span><span class="n">ObjectMeta</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c">// Update the status if necessary</span>
	<span class="n">status</span> <span class="o">:=</span> <span class="n">batchv1</span><span class="o">.</span><span class="n">PodSetStatus</span><span class="p">{</span>
		<span class="n">PodNames</span><span class="o">:</span>      <span class="n">availableNames</span><span class="p">,</span>
		<span class="n">ReadyReplicas</span><span class="o">:</span> <span class="n">numAvailable</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="c">// The code first checks whether the podset.Status field is equal to the new status value using the reflect.DeepEqual() function.</span>
	<span class="c">// If the two values are not equal, it means that the status value has been updated and needs to be written back to the Kubernetes API server.</span>
	<span class="k">if</span> <span class="o">!</span><span class="n">reflect</span><span class="o">.</span><span class="n">DeepEqual</span><span class="p">(</span><span class="n">podset</span><span class="o">.</span><span class="n">Status</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">podset</span><span class="o">.</span><span class="n">Status</span> <span class="o">=</span> <span class="n">status</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">Status</span><span class="p">()</span><span class="o">.</span><span class="n">Update</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">TODO</span><span class="p">(),</span> <span class="n">podset</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">log</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"Failed to update PodSet status"</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ctrl</span><span class="o">.</span><span class="n">Result</span><span class="p">{},</span> <span class="n">err</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="n">numAvailable</span> <span class="o">==</span> <span class="n">podset</span><span class="o">.</span><span class="n">Spec</span><span class="o">.</span><span class="n">Replicas</span> <span class="p">{</span>
		<span class="c">// If the number of available pods is equal to the number of replicas specified in the podset.Spec.Replicas field,</span>
		<span class="c">// then the controller returns a ctrl.Result{} object without an error to indicate that the reconciliation is complete.</span>
		<span class="k">return</span> <span class="n">ctrl</span><span class="o">.</span><span class="n">Result</span><span class="p">{},</span> <span class="no">nil</span>
	<span class="p">}</span>

	<span class="c">// Scale up or down</span>
	<span class="k">if</span> <span class="n">numAvailable</span> <span class="o">&gt;</span> <span class="n">podset</span><span class="o">.</span><span class="n">Spec</span><span class="o">.</span><span class="n">Replicas</span> <span class="p">{</span>
		<span class="n">log</span><span class="o">.</span><span class="n">Info</span><span class="p">(</span><span class="s">"Scaling down pods"</span><span class="p">,</span> <span class="s">"Currently available"</span><span class="p">,</span> <span class="n">numAvailable</span><span class="p">,</span> <span class="s">"Required replicas"</span><span class="p">,</span> <span class="n">podset</span><span class="o">.</span><span class="n">Spec</span><span class="o">.</span><span class="n">Replicas</span><span class="p">)</span>
		<span class="n">diff</span> <span class="o">:=</span> <span class="n">numAvailable</span> <span class="o">-</span> <span class="n">podset</span><span class="o">.</span><span class="n">Spec</span><span class="o">.</span><span class="n">Replicas</span>
		<span class="n">dpods</span> <span class="o">:=</span> <span class="n">available</span><span class="p">[</span><span class="o">:</span><span class="n">diff</span><span class="p">]</span>
		<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">dpod</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">dpods</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">Delete</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">TODO</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">dpod</span><span class="p">)</span> <span class="c">// Writer interface --&gt; Create Delete Update ...</span>
			<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
				<span class="n">log</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"Failed to delete pod"</span><span class="p">,</span> <span class="s">"pod.name"</span><span class="p">,</span> <span class="n">dpod</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ctrl</span><span class="o">.</span><span class="n">Result</span><span class="p">{},</span> <span class="n">err</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ctrl</span><span class="o">.</span><span class="n">Result</span><span class="p">{</span><span class="n">Requeue</span><span class="o">:</span> <span class="no">true</span><span class="p">},</span> <span class="no">nil</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="n">numAvailable</span> <span class="o">&lt;</span> <span class="n">podset</span><span class="o">.</span><span class="n">Spec</span><span class="o">.</span><span class="n">Replicas</span> <span class="p">{</span>
		<span class="n">log</span><span class="o">.</span><span class="n">Info</span><span class="p">(</span><span class="s">"Scaling up pods"</span><span class="p">,</span> <span class="s">"Currently available"</span><span class="p">,</span> <span class="n">numAvailable</span><span class="p">,</span> <span class="s">"Required replicas"</span><span class="p">,</span> <span class="n">podset</span><span class="o">.</span><span class="n">Spec</span><span class="o">.</span><span class="n">Replicas</span><span class="p">)</span>
		<span class="c">// Define a new Pod object</span>
		<span class="n">pod</span> <span class="o">:=</span> <span class="n">newPodForCR</span><span class="p">(</span><span class="n">podset</span><span class="p">)</span>
		<span class="c">// Set PodSet instance as the owner and controller</span>
		<span class="c">// This ensures that the new pod is "owned" by the PodSet object and is managed by the controller.</span>
		<span class="c">// When a child object is created, it is important to set a reference to its owner object using the SetControllerReference function.</span>
		<span class="c">// This ensures that the owner object is set as the "controller" of the child object,</span>
		<span class="c">// which allows Kubernetes to automatically manage the child object's lifecycle and ensures that it is deleted when the owner object is deleted.</span>
		<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">controllerutil</span><span class="o">.</span><span class="n">SetControllerReference</span><span class="p">(</span><span class="n">podset</span><span class="p">,</span> <span class="n">pod</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">Scheme</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">ctrl</span><span class="o">.</span><span class="n">Result</span><span class="p">{},</span> <span class="n">err</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">TODO</span><span class="p">(),</span> <span class="n">pod</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">log</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s">"Failed to create pod"</span><span class="p">,</span> <span class="s">"pod.name"</span><span class="p">,</span> <span class="n">pod</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ctrl</span><span class="o">.</span><span class="n">Result</span><span class="p">{},</span> <span class="n">err</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ctrl</span><span class="o">.</span><span class="n">Result</span><span class="p">{</span><span class="n">Requeue</span><span class="o">:</span> <span class="no">true</span><span class="p">},</span> <span class="no">nil</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ctrl</span><span class="o">.</span><span class="n">Result</span><span class="p">{},</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="c">// TODO: Add a function called newPodForCR() that creates a new pod object for the podset object passed as an argument.</span>
<span class="c">// args: podset *batchv1.PodSet</span>
<span class="c">// newPodForCR returns a busybox pod with the same name/namespace as the cr</span>
<span class="k">func</span> <span class="n">newPodForCR</span><span class="p">(</span><span class="n">cr</span> <span class="o">*</span><span class="n">batchv1</span><span class="o">.</span><span class="n">PodSet</span><span class="p">)</span> <span class="o">*</span><span class="n">corev1</span><span class="o">.</span><span class="n">Pod</span> <span class="p">{</span>
	<span class="c">// creates a map of labels called labels, which contains two key-value pairs:</span>
	<span class="c">// app set to the name of the PodSet object, and version set to "v0.1".</span>
	<span class="c">// These labels are used to identify the pods created by the PodSet object.</span>
	<span class="n">labels</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
		<span class="s">"app"</span><span class="o">:</span>     <span class="n">cr</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span>
		<span class="s">"version"</span><span class="o">:</span> <span class="s">"v0.1"</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">corev1</span><span class="o">.</span><span class="n">Pod</span><span class="p">{</span>
		<span class="n">ObjectMeta</span><span class="o">:</span> <span class="n">metav1</span><span class="o">.</span><span class="n">ObjectMeta</span><span class="p">{</span>
			<span class="n">GenerateName</span><span class="o">:</span> <span class="n">cr</span><span class="o">.</span><span class="n">Name</span> <span class="o">+</span> <span class="s">"-pod-"</span><span class="p">,</span> <span class="c">// GenerateName is used to generate a unique name for the pod.</span>
			<span class="n">Namespace</span><span class="o">:</span>    <span class="n">cr</span><span class="o">.</span><span class="n">Namespace</span><span class="p">,</span>
			<span class="n">Labels</span><span class="o">:</span>       <span class="n">labels</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="n">Spec</span><span class="o">:</span> <span class="n">corev1</span><span class="o">.</span><span class="n">PodSpec</span><span class="p">{</span>
			<span class="n">Containers</span><span class="o">:</span> <span class="p">[]</span><span class="n">corev1</span><span class="o">.</span><span class="n">Container</span><span class="p">{</span>
				<span class="p">{</span>
					<span class="n">Name</span><span class="o">:</span>    <span class="s">"busybox"</span><span class="p">,</span>
					<span class="n">Image</span><span class="o">:</span>   <span class="s">"busybox"</span><span class="p">,</span>
					<span class="n">Command</span><span class="o">:</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"sleep"</span><span class="p">,</span> <span class="s">"3600"</span><span class="p">},</span>
				<span class="p">},</span>
			<span class="p">},</span>
		<span class="p">},</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// SetupWithManager sets up the controller with the Manager.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span><span class="n">PodSetReconciler</span><span class="p">)</span> <span class="n">SetupWithManager</span><span class="p">(</span><span class="n">mgr</span> <span class="n">ctrl</span><span class="o">.</span><span class="n">Manager</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">ctrl</span><span class="o">.</span><span class="n">NewControllerManagedBy</span><span class="p">(</span><span class="n">mgr</span><span class="p">)</span><span class="o">.</span>
		<span class="n">For</span><span class="p">(</span><span class="o">&amp;</span><span class="n">batchv1</span><span class="o">.</span><span class="n">PodSet</span><span class="p">{})</span><span class="o">.</span>
		<span class="n">Complete</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="notes"/><summary type="html"><![CDATA[Introduction about k8s operator and a sample code of a very simple controller.]]></summary></entry><entry><title type="html">CrimeMap</title><link href="https://zichengma.github.io/blog/2023/CrimemapUIUC/" rel="alternate" type="text/html" title="CrimeMap"/><published>2023-01-20T15:31:18+00:00</published><updated>2023-01-20T15:31:18+00:00</updated><id>https://zichengma.github.io/blog/2023/CrimemapUIUC</id><content type="html" xml:base="https://zichengma.github.io/blog/2023/CrimemapUIUC/"><![CDATA[<h1 id="cimemap">CimeMap</h1> <p><strong>MySQL, ReactJS, NodeJS, Full-stack application</strong></p> <p>We built a comprehensive database with records of past crimes occurring near UIUC, providing users with the ability to perform the standard Create, Read, Update, and Delete (CRUD) operations on the data through our web page. To further enhance the user experience, we integrated the Google Maps API, allowing users to view the crimes on a map and gain a better understanding of their relative locations. Our web page was created using ReactJS and NodeJS, while the database was implemented on a Google Cloud MySQL server, ensuring secure data storage and efficient retrieval.</p> <h2 id="showase-of-our-map">Showase of our map</h2> <p><strong><a href="https://youtu.be/-z2Pg80oAbs">Demo video</a> is avaliable on YouTube!!</strong></p> <p><strong><a href="https://github.com/ZichengMa/CrimeMapUIUC">Repo</a> is here! There is clear documentation in this repo</strong></p> <p><img src="Untitled.png" alt="First view of our website" width="850"/></p> <p>First view of our website</p> <p><img src="Untitled1.png" alt="The most creative component — Crime Map" width="850"/></p> <p>The most creative component — Crime Map</p>]]></content><author><name></name></author><category term="projects"/><summary type="html"><![CDATA[A full stack project, combined with MySQL database and ReactJS]]></summary></entry><entry><title type="html">ZinixOS</title><link href="https://zichengma.github.io/blog/2023/ZinixOS/" rel="alternate" type="text/html" title="ZinixOS"/><published>2023-01-17T15:18:10+00:00</published><updated>2023-01-17T15:18:10+00:00</updated><id>https://zichengma.github.io/blog/2023/ZinixOS</id><content type="html" xml:base="https://zichengma.github.io/blog/2023/ZinixOS/"><![CDATA[<h1 id="zinixos">ZinixOS</h1> <p>Our OS has been depolyed as an online appication. If you want to have have a try, please click the <a href="https://rong-hash.github.io/zinixos">link</a>.</p> <p><strong>C, x86 assembly, Operating System</strong></p> <p>This ambitious project is a Unix-like operating system built on the qemu virtual machine. It is the culmination of our operating system design course and is a testament to the hard work and dedication we put into this project. We developed this operating system from the ground up, ensuring that we could support a wide range of features and functionalities. We also added a number of unique features to make it stand out from other operating systems. Ultimately, this project was a great success and we are proud of the hard work and dedication we put into making it a reality. I also found great interest in operating system during this course</p> <ul> <li>Basic functionalities: Implemented an operating system supporting fundamental features such as scheduling, interrupts, system calls, exceptions, and file systems.</li> <li>Additionally, self-designed features were utilised to enhance the system, such as an implicit free list and slab cache to implement a virtual memory allocation system. Furthermore, advanced signals, speaker and hard-disk drivers were also implemented to the system, allowing for an increase in functionality and performance.</li> </ul> <h2 id="show-case-of-our-os">Show case of our OS</h2> <p>Two types of memory management</p> <ol> <li>Fixed length memory allocation</li> <li>Variable length memory allocation</li> </ol> <h3 id="fixed-length--slab-cache">Fixed length — Slab Cache</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">In</span> <span class="n">this</span> <span class="n">specific</span> <span class="n">implementation</span><span class="p">,</span> <span class="n">fixed</span> <span class="n">length</span> <span class="n">memory</span> <span class="n">allocation</span> <span class="n">is</span> <span class="n">implemented</span> <span class="n">by</span> <span class="n">two</span> <span class="n">parts</span><span class="p">,</span> <span class="n">memory</span> <span class="n">management</span> <span class="n">unit</span> <span class="n">and</span> <span class="n">memory</span> <span class="n">unit</span><span class="p">.</span>
<span class="n">fixed</span> <span class="n">length</span> <span class="n">diagram</span><span class="o">:</span>
        <span class="o">|</span><span class="n">memory</span> <span class="n">management</span> <span class="n">unit</span><span class="o">|</span>  <span class="o">|</span><span class="n">memory</span> <span class="n">management</span> <span class="n">unit</span><span class="o">|</span>  <span class="o">|</span><span class="n">memory</span> <span class="n">management</span> <span class="n">unit</span><span class="o">|</span>  <span class="p">..........</span>    <span class="o">|</span><span class="n">memory</span> <span class="n">unit</span><span class="o">|</span>  <span class="o">|</span><span class="n">memory</span> <span class="n">unit</span><span class="o">|</span> <span class="o">|</span><span class="n">memory</span> <span class="n">unit</span><span class="o">|</span> <span class="p">.....</span>
        <span class="o">|</span><span class="n">next</span><span class="o">|</span>  <span class="o">---------------&gt;</span>  <span class="o">|</span><span class="n">next</span><span class="o">|</span>  <span class="o">---------------&gt;</span>  <span class="o">|</span><span class="n">next</span><span class="o">|</span>                                      <span class="err">↑</span>              <span class="err">↑</span>             <span class="err">↑</span>
        <span class="o">|</span><span class="n">ptr</span><span class="o">|---------------------|</span><span class="n">ptr</span><span class="o">|---------------------|</span><span class="n">ptr</span><span class="o">|---------------------------------------</span><span class="err">↑</span><span class="o">--------------</span><span class="err">↑</span><span class="o">-------------</span><span class="err">↑</span>
</code></pre></div></div> <p>Data structure: Linked list</p> <ul> <li>Slab_Create ( name , size )</li> <li>destroy , malloc , free</li> <li>Automatically shrinks and grows</li> <li>quick and fast to allocate and free</li> <li>granularity: 1byte - 4kB-8 bytes</li> </ul> <h3 id="variable-length--implicit-free-list">Variable length — Implicit free list</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">On</span> <span class="n">the</span> <span class="n">other</span> <span class="n">hand</span><span class="p">,</span> <span class="n">variable</span> <span class="n">length</span> <span class="n">memory</span> <span class="n">allocation</span> <span class="n">is</span> <span class="n">implemented</span> <span class="n">very</span> <span class="n">similar</span> <span class="n">to</span> <span class="n">Linux</span><span class="err">'</span><span class="n">s</span> <span class="n">implicit</span> <span class="n">free</span> <span class="n">list</span> <span class="n">design</span><span class="p">.</span> 
<span class="n">A</span> <span class="n">memory</span> <span class="n">part</span> <span class="n">consists</span> <span class="n">of</span> <span class="n">two</span> <span class="n">parts</span><span class="p">,</span> <span class="n">memory</span> <span class="n">management</span> <span class="n">unit</span> <span class="n">and</span> <span class="n">real</span> <span class="n">useable</span> <span class="n">memory</span> <span class="n">unit</span><span class="p">.</span>
<span class="n">Memory</span> <span class="n">management</span> <span class="n">units</span> <span class="n">are</span> <span class="n">held</span> <span class="n">in</span> <span class="n">a</span> <span class="n">linked</span> <span class="n">list</span> <span class="n">to</span> <span class="n">track</span> <span class="n">each</span> <span class="n">memory</span> <span class="n">fragments</span> <span class="n">have</span> <span class="n">been</span> <span class="n">allocated</span><span class="p">.</span>
<span class="n">variable</span> <span class="n">length</span> <span class="n">diagram</span><span class="o">:</span>
        <span class="o">|</span><span class="n">memory</span> <span class="n">mangement</span> <span class="n">unit</span><span class="o">|</span> <span class="o">-&gt;</span> <span class="o">|</span><span class="n">memory</span> <span class="n">mangement</span> <span class="n">unit</span><span class="o">|</span> <span class="o">-&gt;</span> <span class="o">|</span><span class="n">memory</span> <span class="n">mangement</span> <span class="n">unit</span><span class="o">|</span> <span class="o">-&gt;</span> <span class="o">|</span><span class="n">memory</span> <span class="n">mangement</span> <span class="n">unit</span><span class="o">|</span>
        <span class="o">-----------------------</span>    <span class="o">-----------------------</span>    <span class="o">-----------------------</span>    <span class="o">-----------------------</span>
        <span class="o">|</span>                     <span class="o">|</span>    <span class="o">|</span>                     <span class="o">|</span>    <span class="o">|</span>                     <span class="o">|</span>    <span class="o">|</span>                     <span class="o">|</span>
        <span class="o">|</span>   <span class="n">useable</span> <span class="n">memory</span>    <span class="o">|</span>    <span class="o">|</span>   <span class="n">useable</span> <span class="n">memory</span>    <span class="o">|</span>    <span class="o">|</span>   <span class="n">useable</span> <span class="n">memory</span>    <span class="o">|</span>    <span class="o">|</span>   <span class="n">useable</span> <span class="n">memory</span>    <span class="o">|</span>
        <span class="o">|</span>                     <span class="o">|</span>    <span class="o">|</span>                     <span class="o">|</span>    <span class="o">-----------------------</span>    <span class="o">|</span>                     <span class="o">|</span>
        <span class="o">|</span>                     <span class="o">|</span>    <span class="o">-----------------------</span>                               <span class="o">-----------------------</span>
        <span class="o">|</span>                     <span class="o">|</span>
        <span class="o">-----------------------</span>

<span class="n">Slab</span> <span class="n">cache</span><span class="err">'</span><span class="n">s</span> <span class="n">implementation</span> <span class="n">is</span> <span class="n">based</span> <span class="n">on</span> <span class="n">fixed</span> <span class="n">length</span> <span class="n">memory</span> <span class="n">allocation</span><span class="p">.</span>
</code></pre></div></div> <p>Data structure: Implicit free list</p> <ul> <li>varmalloc( size )</li> <li>flexible: can allocate any size</li> <li>granularity: 1byte - 4MB</li> </ul> <p><img src="Untitled.png" alt="Memory allocation system and memory supevise system" style="zoom:50%;"/></p> <p>Memory allocation system and memory supevise system</p> <h2 id="signal">Signal</h2> <p>Support users to set handler they define</p> <p>Support sigreturn and set_handler syscall</p> <p>Support five signals:</p> <ol> <li>SIG_DIV_ZERO</li> <li>SIG_SEGFAULT</li> <li>SIG_INTERRUPT</li> <li>SIG_ALARM</li> <li>SIG_USER1</li> </ol> <p><img src="Untitled1.png" alt="signal tests for our signal implementation" style="zoom:50%;"/></p> <p>signal tests for our signal implementation</p> <h2 id="ata-hard-disk-support--file-system">ATA Hard Disk Support &amp; File System</h2> <ul> <li> <p>Writable file system</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">write</span> <span class="nx">fname</span> <span class="nx">contents</span>
</code></pre></div> </div> </li> <li> <p>Persistent Change (after reboot) by saving the change to the hard drive</p> </li> <li> <p>How the file system is loaded and initialized:</p> </li> </ul> <p><img src="Untitled2.png" alt="Untitled" style="zoom: 80%;"/></p> <h2 id="speaker-driver">Speaker Driver</h2> <p>Key mapping:</p> <p>(C3~E4) ZSXDCVGBHNJM,L.;/</p> <p>(C4~G5) Q2W3ER5T6Y7UI9O0P[=]</p> <p>Runs concurrently with any user programs &amp; across terminals</p> <p><img src="Untitled3.png" alt="part of the code for our ‘keyboard piano’" style="zoom:50%;"/></p> <p>part of the code for our ‘keyboard piano’</p>]]></content><author><name></name></author><category term="projects"/><summary type="html"><![CDATA[An operating system project from ECE391.]]></summary></entry><entry><title type="html">MedicalDB</title><link href="https://zichengma.github.io/blog/2023/MedicalDB/" rel="alternate" type="text/html" title="MedicalDB"/><published>2023-01-14T15:33:02+00:00</published><updated>2023-01-14T15:33:02+00:00</updated><id>https://zichengma.github.io/blog/2023/MedicalDB</id><content type="html" xml:base="https://zichengma.github.io/blog/2023/MedicalDB/"><![CDATA[<h1 id="medical-appointment-db">Medical Appointment DB</h1> <p><strong><em>B+ Tree, Hash Table, C++, UI</em></strong></p> <p>This database system is built to distribute medical appointments. We assume there are several hospitals and many patients. Every patient has certain properties used to identify their priority. Based on the priority and hospitals’ capacity, we will assign patients wisely.</p> <p>We used C++ to build a B+ Tree as the base for our database system. To make it more user-friendly, we implemented a UI instead of relying solely on terminal commands. Additionally, we imitated a SQL-style query language to make our system easier to learn for those familiar with SQL.</p> <h3 id="showcase-of-our-project">Showcase of our project</h3> <p><strong><a href="https://github.com/ZichengMa/CS225-DatabaseProject">Repo</a> is here !!!~~~</strong></p> <p><img src="Untitled.png" alt="Untitled" style="zoom: 67%;"/></p> <p><img src="Untitled1.png" alt="Untitled" style="zoom:67%;"/></p> <p><img src="Untitled2.png" alt="Untitled" style="zoom:67%;"/></p>]]></content><author><name></name></author><category term="projects"/><summary type="html"><![CDATA[Self-design database system based on B+Tree. Course project from CS225.]]></summary></entry><entry><title type="html">ECE391-MP3-Tutorial</title><link href="https://zichengma.github.io/blog/2023/ECE391-MP3-Tutorial/" rel="alternate" type="text/html" title="ECE391-MP3-Tutorial"/><published>2023-01-13T17:37:54+00:00</published><updated>2023-01-13T17:37:54+00:00</updated><id>https://zichengma.github.io/blog/2023/ECE391-MP3-Tutorial</id><content type="html" xml:base="https://zichengma.github.io/blog/2023/ECE391-MP3-Tutorial/"><![CDATA[<h1 id="ece391-mp3">ECE391 MP3</h1> <blockquote> <p><strong><em>Notes about all the documents and materials related to ECE391 MP3.</em></strong></p> </blockquote> <blockquote> <p><strong><em>FA22 Group 11 — ZinixOS</em></strong></p> </blockquote> <blockquote> <p>Mmebers: Zicheng Ma, Ziyuan Chen, Zhirong Chen, Shihua Zeng</p> </blockquote> <blockquote> <p>Language: 中文+English</p> </blockquote> <p>FA22 ECE391本人最终评分A+，侧面表明这篇文档在一定程度上还是可以信赖的，而且有我的队友对文档进行查改和补充<del><em>但如果写出bug，本人概不负责</em></del> 🤣 😋</p> <p>REFERENCE: OSdev相关资料，TA Jerry Wang’s slides</p> <h1 id="checkpoint-1">Checkpoint 1</h1> <h2 id="os-booting-gdt--idt-setup">OS Booting: GDT &amp; IDT Setup</h2> <h3 id="gdt">GDT</h3> <p>reference: <a href="https://wiki.osdev.org/Global_Descriptor_Table">https://wiki.osdev.org/Global_Descriptor_Table</a></p> <p>在<code class="language-plaintext highlighter-rouge">x86_desc.S</code>中创建<code class="language-plaintext highlighter-rouge">gdt_desc</code>标记（参考<code class="language-plaintext highlighter-rouge">ldt_desc</code>）</p> <ul> <li>48bytes，包括<code class="language-plaintext highlighter-rouge">.word</code>长度的limit和<code class="language-plaintext highlighter-rouge">.long</code>长度的base</li> </ul> <p>在<code class="language-plaintext highlighter-rouge">boot.S</code>中用<code class="language-plaintext highlighter-rouge">lgdt gdt_desc</code>载入</p> <h3 id="idt">IDT</h3> <p>reference: <a href="https://wiki.osdev.org/Interrupt_Descriptor_Table">https://wiki.osdev.org/Interrupt_Descriptor_Table</a></p> <p>在<code class="language-plaintext highlighter-rouge">interrupt.c</code>中定义handlers</p> <ul> <li>对于Exception，打印错误信息+无限循环（“蓝屏”）<strong>（后续ckpt会处理如何跳出无限循环）</strong></li> <li>对于Interrupt，在函数体中调用linkage<strong>**</strong><strong>**</strong>（无参数）<strong>**</strong><strong>**</strong>，在asm中定义linkage函数（Push all, call handler, pop all, <strong>**</strong><strong>iret</strong><strong>**</strong>） <ul> <li>需要调用linkage的原因是，C function在结束后默认使用ret，而interrupt结束后需要从kernel跳回到user space，使用的是iret。利用asm linkage来完成这一步跳转，用C function来完成每个interrupt handler的具体工作。</li> </ul> </li> <li>利用定义好的SET_IDT_ENTRY来设置IDT中指向的linkage/function</li> </ul> <h2 id="device-and-interrupt">Device and Interrupt</h2> <hr/> <h3 id="pic">PIC</h3> <p>reference:<a href="https://wiki.osdev.org/PIC">https://wiki.osdev.org/PIC</a></p> <p>PIC所使用port位置</p> <p><img src="Untitled.png" alt="" width="250"/></p> <p>在IDT中，PIC_MASTER使用<strong>0x20-0x27</strong> vector呼叫handler，PIC_SLAVE使用<strong>0x28-0x2F</strong>呼叫handler</p> <p>PIC_SLAVE链接到PIC_MASTER的<strong>2号vector</strong></p> <p><strong><em>Initialization:</em></strong></p> <ol> <li>mask掉所有interrupt（向data port传入0xff）</li> <li>先给予0x11 command，然后PIC会等待接下来3个传入参数进行初始化（ICW1)</li> <li>接下来确定在IDT中的位置(ICW2)</li> <li>决定Master和Slave的cascade状况(ICW3)</li> <li>最后向Data port传入这是x86模式，以适配x86模式进行工作</li> </ol> <p>主要对着Lecture10 PPT写即可</p> <hr/> <p><strong><em>enable_irq / disable_irq:</em></strong></p> <p>PIC内部存在一个register Interrupt Mask Register，共8bit，当对应bit位被set为1时，PIC会忽略对应位置irq。注意: mask数字高的irq不会影响数字低的irq（priority更高的irq）</p> <p>先判断irq是否超过7，若超过7，向PIC_SLAVE的data port传入数据，否则向PIC_MASTERdata port传入数据</p> <p><img src="Untitled1.png" alt="" width="320"/> <img src="Untitled2.png" alt="" width="320"/></p> <hr/> <p><strong><em>send_EOI:</em></strong></p> <p>同样需要检查irq number。无论如何都要给MASTER command port send EOI，如果是SLAVE的handler结束，那就给SLAVE也补上</p> <p>注意: 我们的代码中EOI在send之前需要和irq做一个OR操作，以告知PIC是哪一个irq结束</p> <p><img src="Untitled3.png" alt="Untitled" width="320"/></p> <p>补充：以上函数均需要做<strong>sanity check</strong>，不允许传入的irq number是一个0-15以外的数值</p> <hr/> <h3 id="rtc">RTC</h3> <p>RTC可以以多个频率运行，基础频率32.768kHz，可以用divider register改变，但是不要变，要不然不准。对于interrupt，默认产生interrupt的频率是1024Hz，可以自行修改，the RTC can theoretically generate <strong>15 interrupt rates between 2 Hz and 32768 Hz (</strong>2^1-2^15)</p> <p>RTC handler期间，禁用NMI，否则导致RTC变成不可用状态</p> <p>RTC使用<strong>port 0x70和0x71</strong>，0x70用来指示用哪个register，0x71包含数据。在选择register时可以顺带mask掉NMI</p> <p><img src="Untitled4.png" alt="Untitled" width="750"/></p> <hr/> <p><strong><em>Initialization:</em></strong></p> <ol> <li>打开IRQ8 这里reset原因是每次读写完之后，port 0x70的内容都会被清零，需要重新指定register，然后在这之后要<code class="language-plaintext highlighter-rouge">enable_irq(8)</code></li> </ol> <p><img src="Untitled5.png" alt="Untitled" width="750"/></p> <ol> <li> <p>选择interrupt产生的frequency</p> <p>寄存器A的低4位，是divider value，默认位0110即6，所以默认frequency = 2^15»(6-1) = 1024</p> <p>设置好寄存器A的低4位(称为rate)后，最终<strong>frequency = 2^15 »(rate-1)</strong></p> <p><strong>rate最低只能选3</strong>，低于3会roll over，导致interrupt频率不准</p> <p><img src="Untitled6.png" alt="Untitled" width="750"/></p> </li> </ol> <hr/> <p><strong><em>handler:</em></strong></p> <p>需要使用一个全局变量，并且需要volatile，来记录RTC产生interrupt的次数，当做时钟</p> <p>这个数字，除以frequency，就可以得到当前过了多少秒，或者多少ms</p> <ol> <li> <p><strong>if register C is not read after an IRQ 8, then the interrupt will not happen again</strong></p> <p>在每次handler之后需要加入一段</p> <p><img src="Untitled7.png" alt="Untitled"/></p> </li> <li> <p>然后send_EOI，STI</p> </li> </ol> <hr/> <h3 id="keyboard">Keyboard</h3> <p>键盘本身属于PS/2 controller，使用PS/2的port。读取键盘内容从<strong>0x60</strong>端口获得，<strong>connect to irq1</strong></p> <p><img src="Untitled8.png" alt="Untitled"/></p> <p>command为一个byte，键盘会response “ACK” (to acknowledge the command) or a “Resend” (to say something was wrong with the previous command)</p> <p>scan code set会表示哪个键被下压。scan code可能不止一个，最多6个bytes。当keyboard状态机知道现在scan code已经全部获取了，就可以将其转化成key code了。</p> <p>我们的键盘属于US QWERTY，用SCAN CODE SET1</p> <p><strong><em>Initialization:</em></strong></p> <p>只需要enable_irq即可</p> <p><strong><em>handler:</em></strong></p> <ol> <li>从port中读取数据 <code class="language-plaintext highlighter-rouge">inb(0x60)</code></li> <li>利用提前建好的table对应ASCII <ol> <li>检测是否为特殊键 shift caps…. 如果是，暂时不做任何操作（或者可以在这个ckpt就把这个东西弄好）</li> <li>对普通键，对应ASCII码并putc</li> </ol> </li> <li>send EOI</li> </ol> <h2 id="paging">Paging</h2> <p>reference: <a href="https://wiki.osdev.org/Paging">https://wiki.osdev.org/Paging</a></p> <h3 id="kernelc">kernel.c</h3> <p>在 <code class="language-plaintext highlighter-rouge">kernel.c</code> 的 <code class="language-plaintext highlighter-rouge">entry</code>函数中添加 <code class="language-plaintext highlighter-rouge">page_init</code>函数， 调用 <code class="language-plaintext highlighter-rouge">page.c</code>中初始化分页的代码</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Init the PIC */</span>
	<span class="n">i8259_init</span><span class="p">();</span>

<span class="cm">/* Init paging */</span>
	<span class="n">page_init</span><span class="p">();</span>
</code></pre></div></div> <h3 id="pagec-pageh">page.c, page.h</h3> <ol> <li>在新文件 <code class="language-plaintext highlighter-rouge">page.h</code> 以及 <code class="language-plaintext highlighter-rouge">page.c</code> 中定义相关函数和数据结构 <ul> <li>page table需要自定义数据结构，参照OSdev或者x86手册</li> </ul> </li> <li>定义函数 <ul> <li>需要完成对 <strong>page directory table</strong> 和 两个 <strong>page table</strong> 的初始化，并且写入内存中对应位置。page init部分实际上就是修改创建好的page tables中各个bit的值，对应所需要开启的paging部分</li> <li>需要操作 CPU 的 <code class="language-plaintext highlighter-rouge">cr0</code>, <code class="language-plaintext highlighter-rouge">cr3</code>, <code class="language-plaintext highlighter-rouge">cr4</code> 寄存器，告知硬件page directory的位置并为 paging 开启硬件支持。这一步相当于激活上面一步初始化好的page directory和page table</li> <li>cr0用于开启paging cr4用于开启4MB page cr3为TLB，即指示page directory位置</li> </ul> <p>page directory entry 和 page table entry 的结构：</p> <p><img src="Untitled9.png" alt="Untitled"/></p> </li> </ol> <h1 id="checkpoint-2">Checkpoint 2</h1> <h2 id="terminal-driver">Terminal Driver</h2> <hr/> <p>ToDo:</p> <ol> <li>完善键盘映射：Shift、CapsLock（Ctrl和Alt也需要用全局变量追踪，暂时没有更多作用——TA）</li> <li>光标追踪：让打的字出现在光标处，需要支持上下滑动（其实只有向上；可以不用保留command history）。还需要支持Ctrl+L/Ctrl+l的清屏操作</li> <li>还需要支持退格键（直接改变光标）和行缓冲输入，缓冲区大小128B</li> </ol> <p><strong>read:</strong></p> <p>从keyboard buffer中读取写入的字符，转移到terminal buffer中，返回读取的bytes总数</p> <p>设置while循环，不断通过键盘向keyboard buffer中增加内容，扫描到enter才返回。缓冲区换入127个字符时，拒绝新进入的字符（停止更新缓冲区），等待一个enter的输入。（最后一个字符应为\n）</p> <p>对于terminal，read多少字符，就把buffer中的多少个字符给清空，并将后面的挪动到前面来</p> <p>^ 其实可以直接覆写</p> <p>read有两种情况会终止，第一种是read到指定byte数目，第二种是碰到了\n（其实只有一种？）</p> <p>^ 只在读到\n时返回即可，越界时直接忽略后面的字符</p> <p><strong>write:</strong></p> <p>从传入的buf中读取所有内容，转移到屏幕上，返回written bytes数目或者-1</p> <p><strong>注意需要滚动换行↓的情况：打印字符计数达到80时触发scrolling函数</strong></p> <p><strong>scrolling:</strong></p> <p>可能要修改putc函数，将上方所有内容向上移动一行，把最底下一行清空，然后再打印新的字符（直接更新vmem）</p> <p><strong>clear:</strong></p> <p>lib.c中的clear函数只有清理video memory的操作，没有重置下一个character应该出现的位置</p> <p>↑但仍然是好事，差点就要写循环往vmem里赋零了（）</p> <h2 id="read-only-file-system">Read-only File system</h2> <hr/> <p>ToDo:</p> <ol> <li>open and read a file system image</li> <li>copy program images into physical memory</li> </ol> <h3 id="基本数据结构">基本数据结构</h3> <p>每个Block 4kB，第一个block称为boot block，包含file system的整体统计信息（dir数量、inode数量、数据块数量）和所有的directory。统计信息、每个directory均占据64B</p> <p>第一个directory总是代表当前directory，命名为.（一个点），所以实际上最多只能有62个其他files</p> <p>每一个directory包含：32B文件名（不一定要包含EOS，也即未必有”\0”标记字符串尾）、4B文件类型、4B inode索引</p> <p><img src="Untitled10.png" alt="Untitled" width="850"/></p> <p>file type 0 代表user level可以触碰的RTC，1 for directory，2 for regular file。对于RTC和directory，#inode是没有意义的。</p> <p><img src="Untitled11.png" alt="Untitled" width="650"/></p> <p>以上三个函数都是失败return -1（fname不存在/index不合法/#inode不合法/inode中数据块索引不合法）。前两个函数成功都会将dentry指针赋值成所需要的那个directory数据，第三个函数相当于“read”这一system call，返回读取了多少个byte</p> <hr/> <p><strong>与Task的联动：</strong></p> <p>每一个task最多开启8个file，它们被存在一个file array中，而file descriptor就是用来在array中找寻这些file的。file array中的每一个元素都应该储存以下四种信息</p> <ol> <li>对应这个file的各种操作函数，<strong>open, read, write, and close</strong> to perform type-specific actions for each operation.</li> <li>inode number，对于directory或者RTC就是0</li> <li>file position，指示用户在什么位置开启了这个file，由read system call更新</li> <li>flag，用来指示当前descriptor正在使用</li> </ol> <p><img src="Untitled12.png" alt="Untitled" width="850"/></p> <p>open a file的流程：储存对应的jump table pointer，将flag设置成in-use</p> <hr/> <h3 id="filesystem_init">filesystem_init</h3> <ol> <li> <p>找到File img的开头地址，File的所有信息在boot的时候就已经帮我们储存在了内存的某一个地方</p> <p>根据文档，每一个img都算是一个module，可以load进去</p> <p><img src="Untitled.jpeg" alt="Untitled" width="750"/></p> <p><img src="Untitled13.png" alt="Untitled" width="650"/></p> </li> <li>在<code class="language-plaintext highlighter-rouge">kernel.c</code>里进行file system初始化，将上面找到的指针传递给file system</li> <li>传入的地址是boot_blcok的开头，直接将一个全局变量boot_block_ptr指向这个地方</li> <li>boot_block中的3个num信息，赋值给3个全局变量，用于储存有多少个directory，有多少个inode，有多少个data_block</li> <li>根据各个数字，找到inode的开头和data_block的开头，并将这两个地址储存在另外两个ptr中，以备后续使用</li> </ol> <p>tips：因为文件系统只读不写，可以用静态的全局变量储存这些所有信息</p> <hr/> <h3 id="three-base-functions">Three base functions</h3> <p><strong>read_dentry_by_index:</strong></p> <ol> <li>sanity check，如果index超出dir_num，return -1</li> <li>将boot_block中的<code class="language-plaintext highlighter-rouge">dentries[index]</code>值赋给传入的dentry指针 <ol> <li>赋值过程中，filename必须用<code class="language-plaintext highlighter-rouge">lib.c</code>提供的<code class="language-plaintext highlighter-rouge">strncpy</code>，因为filename允许没有string结尾符<code class="language-plaintext highlighter-rouge">\0</code></li> </ol> </li> </ol> <p><strong>read_dentry_by_name:</strong></p> <ol> <li>设置一个index变量，遍历所有在boot_block的file name，每次index++</li> <li>index++之后做check，如果已经超出dir_num，return -1</li> <li>如果匹配到（利用<code class="language-plaintext highlighter-rouge">lib.c</code>中提供的<code class="language-plaintext highlighter-rouge">strncmp</code>），呼叫<code class="language-plaintext highlighter-rouge">read_dentry_by_index(index, dentry)</code>，让read_dentry_by_index完成真正的赋值操作</li> </ol> <p><strong>read_data:</strong></p> <ol> <li>sanity check，确认(file总长度-offset)&gt;0 并且 inode_index &lt; boot_block拥有的inode数目-1</li> <li>找到对应的inode，<code class="language-plaintext highlighter-rouge">inodes_arr[i]</code></li> <li>计算需要从哪个data_block的哪个位置开始读取 offset / block_size + offset % block_size</li> <li>计算读取到哪个data_block的哪个位置</li> <li>开始循环复制数据到buff中，同时要检测是否需要更换另一个data_block</li> </ol> <hr/> <p>问题：我们需要在这里实现file descriptor array吗？暂时不需要，在之后的scheduler部分出现了task struct再实现</p> <hr/> <h2 id="the-real-time-clock-driver">The Real-Time Clock Driver</h2> <p>reference:<a href="https://wiki.osdev.org/RTC">https://wiki.osdev.org/RTC</a></p> <p>做到和RTC交互，让user直接修改它的频率，最好能<strong>虚拟化</strong></p> <p>虚拟化可以采用一个全局变量counter，每次interrupt产生都++，这里的interrupt看做是一个基础interrupt，采取最高频率，即1024Hz</p> <p>对于不同频率，如果counter自这个read函数被创建后过了 1024/frequency次，则return</p> <p>例如：虚拟化的RTC_read需要一个512Hz的RTC，那么过了1024/512=2个interrupt后return</p> <p>可能需要一个array，全部entries初始化为1，对不同的虚拟的RTC device储存各自的频率，interrupt实际上只改变counter。在后续ckpt中，有多个terminal，每一个terminal上执行的程序可能会设置不同的RTC频率，对应这个array中的一个freq</p> <p><strong>open:</strong></p> <p>将freq改为2Hz，返回0。flag设置为0。后续到了多进程时，freq和flag都有多个，每个进程对应一对freq和flag。</p> <p><strong>close:</strong></p> <p>返回0（文档如此）</p> <p><strong>read:</strong></p> <p>跟踪全局flag，用一个while loop让read函数陷入循环，直到flag被设置成1，跳出循环。跳出时再重新将flag设置为0，return。这样可以达到一种类似于linux中sleep的效果。</p> <p><strong>write:</strong></p> <p>先做sanity check，如果都通过，根据传入的frequency设置freq。此时暂时只有一个terminal，没有进程之间的切换，在后续ckpt中需要检查当前write指令是由哪一个进程调用的，修改这个进程对应的freq</p> <p><strong>handler:</strong></p> <p>使counter++，检查是否度过了freq个单位时间，如果是，将flag设置为1。设置为1的时候，之前某次调用的read函数就会返回。</p> <p>具体相关端口，对rtc的交互请查看reference（OSdev）</p> <hr/> <h1 id="checkpoint-3">Checkpoint 3</h1> <h2 id="system-calls">System Calls</h2> <p>int $0x80呼叫，最多接受三个参数</p> <p>call number, arg1, arg2, arg3 → EAX, EBX, ECX, EDX</p> <p>成功return 0，失败return -1，返回值放在EAX</p> <p>一部分不会返回（如halt）</p> <p><strong>open</strong></p> <p>在文件系统中找到文件，分配一个空闲的描述符并初始化（注意文件类型）</p> <p><strong>close</strong></p> <p>检测描述符合法性，后释放描述符</p> <p><strong>read</strong></p> <p>从RTC/键盘/文件/目录读取数据，返回读取的bytes数量</p> <p>RTC：接收到virtual interrupt时返回0</p> <p>键盘：读取到\n时 或 buffer满时返回</p> <p>文件：读取到EOF时 或 buffer满时返回</p> <p>File Position指读取位置</p> <p>system call的传入参数性质也决定了我们需要为它们编写一个wrapper(link)来保证参数正常传递</p> <hr/> <h3 id="wrapper--linkage">Wrapper &amp; Linkage</h3> <p>需要实现的10个system call最多只有三个参数，用asm写wrapper <strong>（这部分并不归我们写，提供的可执行文件包含了这部分wrapper）</strong></p> <p>在IDT的0x80号位置调用包装函数</p> <ol> <li>callee saved</li> <li>获取arguments，根据数目不同从EBX, ECX, EDX中获取</li> <li>获取system call number，<code class="language-plaintext highlighter-rouge">int 0x80</code></li> <li>restore callee saved</li> </ol> <hr/> <h3 id="system-call-handler">System call handler</h3> <ol> <li>save all registers</li> <li>check system call number is valid or not</li> <li> <p>利用已有的function table找到对应system call，从call之后的stack来看，获取参数应该在每一个system call所对应的函数之内 — 问题：如何让一个C function直接从寄存器中读取数值，fastcall？</p> <p>或者<strong>另一种解决办法，直接在system call handler中恢复C convention</strong></p> <p><img src="Untitled14.png" alt="Untitled"/></p> </li> <li>检查返回值，失败与成功</li> <li>restore register</li> <li>重新设置关于iret所需要的一切</li> <li>iret</li> </ol> <hr/> <h3 id="execute-sys-call具体流程">Execute sys call具体流程</h3> <p>尝试加载一个新的程序</p> <p>接收参数command（字符串）是一个以空格为分界的一连串words，第一个word是file name，之后的都由getargs获得</p> <p>无法执行（命令不存在、非可执行文件）返回-1，Exception返回256，halt返回0~255的值</p> <p><strong>Parse args</strong></p> <p>对于<strong>file name</strong>，直接取出第一个空格之前的所有内容即可，写一个loop，直到char == ’ ’停止</p> <p>其他的arguments暂时好像用不到</p> <p><strong>Check file validity</strong></p> <ol> <li>利用file name检查file中是否存在一样的文件，在这里利用<strong>read_dentry_by_name</strong>时可以把信息存在一个dentry变量中，接下来需要使用</li> <li>再读取这个file的前4个bytes（<strong>read_data</strong>），查看它是否是一个可执行文件</li> <li>在这里也可以直接获取program第一条指令执行的位置（<strong>read_data</strong>），储存在可执行文件的24-27bytes</li> </ol> <p><strong>Create PCBs</strong></p> <p>寻找到pid，当前是第几个process</p> <p>为PCB分配空间，初始化，设置为active，其中kernel stack根据不同的pid有不同的值</p> <p>Open File descriptor for stdin/stdout</p> <p><strong>Set up paging</strong></p> <p>需要知道当前是第几个process，我们应该可以假设最多只有3个process（像PPT上一样）</p> <p>直接在Page Directory中 ( 0x8000000(128MB) »22 )，即2^5=<strong>32位置修改映射</strong></p> <p><strong>phy add = 0x800000 + pid*4MB</strong> 将 PD[32]对应的4MB page起始点修改为 <strong>phy add »12</strong>即可</p> <p>记得flush tlb，即重新载入一遍cr3</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 *   set_user_prog_page
 *   Set page for a user program
 *   input: pid -- the pid of the user program
 *   output: None
 *   side effect: Change the paging directory; Change CR3; flush TLB
 */</span>
</code></pre></div></div> <p><strong>Load file(program) into memory</strong></p> <p>file的起始点为USER_CODE 0x8048000</p> <p><strong>Prepare for context switch</strong></p> <p>mp3 system中只有一个tss，就是在<code class="language-plaintext highlighter-rouge">x86_desc.h</code>中的tss变量，在回到user level之前，tss中的相关参数需要被更新</p> <p>不需要考虑schedule的情况下，只需要更改tss的值即可，在soft multitasking中，tss只有两个值是相关的，<strong>更改SS0为kernel ds，ESP0为当前process的stack，即8MB-8KB*(pid)-1个byte、</strong></p> <aside> ➡️ esp0永远是8MB-8KB*(pid)-1，是因为每次从kernel回到user space，kernel stack都被“清空”，stack上实际的数据没有改变，但下一次回到kernel space，从栈底开始。这样做的原因是防止kernel stack overflow </aside> <p><img src="Untitled15.png" alt="Untitled"/></p> <p>iret需要的五个参数：</p> <ul> <li>user ds，直接用x86_desc.h中的user ds；</li> <li>esp，user stack，位于128MB-132MB这一段memory的末尾，即132MB-4byte；</li> <li>eflag，直接把当前的flag push进去可行吗？</li> <li>cs，tss中的user cs；</li> <li>eip，把上面储存的user program第一条指令对应的地址拿过来</li> </ul> <hr/> <h3 id="halt-sys-call具体流">Halt sys call具体流</h3> <p>终止进程并返回母进程</p> <p>Shell —”execute” syscall (when cmd is typed)→ Program</p> <p>Program —”halt” syscall (when “return”)→ Shell</p> <p>很重要的一点，如果我们要检测是否exception，需要在原来的exception while1改成呼叫halt的函数</p> <p>halt的总体思想，利用parent process在kernel stack上存好的context来iret，以此回到parent process的user level</p> <ol> <li>首先check这是否是exception呼叫的</li> <li>再看一下是否是shell，如果是shell本身出问题，需要重启shell，因为它是第一个program，不能被完全杀死</li> <li>关闭file descriptor，将开启了的file均关闭，因为如果不关闭，之后重新利用这段pcb的时候会发现许多file都是“开启”状态</li> <li>将当前的process设置为non-active</li> <li>找到parent，并从parent的pcb中取出信息，将paging设置为parent program所需要的</li> <li>将tss更新成parent的信息，SS0=kernel ds，ESP0=parent kernel stack</li> <li>再从parent pcb中找到之前的context信息，具体而言，是从parent pcb中重新取回之前的ebp和esp，之后再leave+ret就相当于从execute这个syscall的地方返回，直接用这些context信息来进行iret</li> </ol> <hr/> <h2 id="tasks">Tasks</h2> <p>此次不用完成scheduler，但需要在某一个program产生exception时回到shell</p> <p>所有tasks共享一个4MB内核态分页。对于一个而言，其task映像（代码）的物理地址是固定的而且每个小于4MB，分配一个用户态分页即可。</p> <hr/> <h2 id="loader">Loader</h2> <p>在文件系统驱动中，将程序代码从随机分配&amp;排列（也即分散）的4kB disk blocks拷贝到连续的物理地址中</p> <p>注意维护栈，拷贝在内核态执行，拷贝结束后要回到用户态</p> <hr/> <h2 id="executing-user-level-code">Executing User-level Code</h2> <p>注意内核态程序不能调用用户态程序，要实现privilege switch</p> <p>IRET的正常运行要求提供ESP EIP EFLAGS CS SS等寄存器值</p> <p>EIP → 位于可执行文件24~27B的entry point</p> <p>ESP → 载入可执行文件的4MB分页末尾</p> <p>CS → user code segment</p> <p>DS → user data segment</p> <p>SS → user stack segment （有声明吗？）</p> <p>而且需改变TSS</p> <hr/> <h2 id="process-control-block">Process Control Block</h2> <p>需储存的Per-Task State包括</p> <p>File array（记录开启的文件）</p> <p>Signal information → extra credit内容，可以不识闲</p> <p>Kernel stack（每个8kB）</p> <p>两个task的kernel stack分别占用第4080~4087、4088~4095kB</p> <p>parent pid</p> <p>excute_ebp / excute_esp 用于halt</p> <hr/> <h1 id="checkpoint-4">Checkpoint 4</h1> <h2 id="getargs">getargs</h2> <p>在execute内调用</p> <p>参数（以字符串的形式）存储在PCB，裁剪（头部）可执行文件名&amp;空格、（尾部）空格</p> <p>例：在Shell #0中运行” cat arg1 arg2 “，将”arg1 arg2”存入PCB #1（注意空格数量）</p> <h3 id="步骤">步骤</h3> <p>在buf中传入用户输入的命令</p> <p>检测头部空格结束的位置、尾部空格开始的位置</p> <p>将两个位置之间的args字符串拷贝进PCB（args之间可以有任意数量空格，交给user program处理）</p> <p>成功返回0，失败（args+NULL太大/检测不到args）返回-1</p> <p>最好把PCB #0（shell）的args字符串设置为”\0”</p> <h2 id="vidmap">vidmap</h2> <p>需要DPL = 0以访问物理内存vmem，影响安全性。解决方案为将vmem映射到虚拟内存</p> <p>*screen_start指向虚拟内存地址（用户给定）</p> <p>双重指针的作用是允许访问整个新的4kB page</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// implimentation</span>
<span class="kt">uint8_t</span><span class="o">*</span> <span class="n">screen_start</span> <span class="o">=</span> <span class="n">vidmap</span><span class="p">();</span>
<span class="c1">// or</span>
<span class="n">uint_t</span><span class="o">*</span> <span class="n">screen_start</span><span class="p">;</span>
<span class="n">vidmap</span><span class="p">(</span><span class="n">screen_start</span><span class="p">);</span>
</code></pre></div></div> <h3 id="步骤-1">步骤</h3> <p>检查*screen_start的合法性：应大于128MB，小于132MB（？）</p> <p>修改PD和PT实现mapping，将DPL设置为3供用户访问（？）</p> <p>成功返回<strong>0xB8000</strong>，失败返回-1</p> <hr/> <h1 id="checkpoint-5">Checkpoint 5</h1> <h2 id="multiple-terminals">Multiple Terminals</h2> <p>3个terminal，最多同时运行6个程序</p> <h3 id="initialization">Initialization</h3> <ul> <li>Initial bootup: 在系统启动时就初始化三个进程</li> <li>After bootup: 用Alt+F1/F2/F3切换，当用户第一次按下ALT+F2/F3时开启新的terminal</li> </ul> <h3 id="separate-io-buffer">Separate I/O buffer</h3> <p>每一个terminal结构体中存储独立的I/O buffer、光标、显示屏上的文字、active flag</p> <p>在切换出terminal的时候存起来，切换回来的时候重新载入</p> <h3 id="isolation">Isolation</h3> <p>退出某一个terminal的shell时，不会立即重启，直到把最后一个shell也退出时才需要重启shell</p> <p>在halt修改一下重启条件，判断是否是最后一个shell</p> <h3 id="switch">Switch</h3> <p><img src="Untitled16.png" alt="multi terminal 内存示意图" width="850"/></p> <p>multi terminal 内存示意图</p> <p>需要新分配三块backup video memory，类似build buffer的作用，每一块都储存着当前terminal的video memory，在切换的时候进行载入</p> <h3 id="步骤-2">步骤</h3> <p>在<code class="language-plaintext highlighter-rouge">terminal.c</code>中定义<code class="language-plaintext highlighter-rouge">void switch_terminal(uint8_t term_index)</code>函数，在<code class="language-plaintext highlighter-rouge">keyboard.c</code>中调用</p> <ol> <li>Sanity check，传入index是否越界</li> <li>判断term_index是否为当前current_term_index（全局变量），若是则直接返回</li> <li>切换流程(以从terminal1切换到terminal2为例子) <ol> <li>video map到current terminal，即让0xB8000指向phyiscal的0xB8000</li> <li>将当前vmem存到属于terminal1的backup内存块（term1 video page）中</li> <li>将terminal2的backup内存块载入vmem</li> <li>设置光标位置，此时屏幕更新完成</li> <li>更新全局变量current_term_id</li> <li>video map到当前正在schedule的process</li> </ol> </li> </ol> <p>tips: video map指的是更新virtual 0xB8000指向的physical memory映射关系，以下为函数的描述</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*   remap_vidmap_page
 *   Set page for video memory for a specific terminal.
 *   If terminal_id = active one, directly write into physical memory.
 *   If terminal_id != active one, map user video memory to corresponding backup buffer.
 *   input: screen_start -- starting address of the video memory
 *   output: None
 *   side effect: Change the paging directory; Change CR3; flush TLB */</span>
</code></pre></div></div> <hr/> <h2 id="scheduling">Scheduling</h2> <p>跟踪所有活跃的task，每隔10-50ms轮流切换执行</p> <p>被暂停的task不应该打印信息，需要动态更新page table以将显示映射到0xB8000以外的地方</p> <h3 id="pit">PIT</h3> <p>reference: <a href="https://wiki.osdev.org/PIT">OSDEV Link for PIT</a></p> <p>Scheduling中计时使用PIT而非RTC，因为RTC的优先级太低了</p> <p>在PIT发生一次interrupt时调用handler（在IDT中注册），在handler中进行一次schedule操作</p> <p>使用Chanel0作为I/O Port <code class="language-plaintext highlighter-rouge">0x40 Channel 0 data port (read/write)</code></p> <p>向0x43 port写入选择的channel，mode</p> <h3 id="scheduler">Scheduler</h3> <p>在进行具体流程之前，必须明确一个事实。一个不是正在执行的process的stack上，<strong>必然是scheduler的残留信息</strong>，因为process只要开始执行，只有两种可能退出当前stack：</p> <ol> <li>执行完毕，返回user space</li> <li>还未执行完毕，但是被scheduler强制退出，去往其他process</li> </ol> <p>所以只要我们发现可以找到next process，那这个process一定是属于2情况，即stack上残留了上一次scheduler未return的所有信息，在接下来的task switch中，以为switch的时候依然使用的是scheduler的代码，直接更改esp、ebp即可</p> <p><img src="Untitled17.png" alt="Untitled" width="850"/></p> <h3 id="步骤-3">步骤</h3> <p><strong>核心思想1：scheduler通过更改esp, ebp实现在kernel stack之间的切换</strong></p> <ol> <li>PIT产生interrupt，在其<code class="language-plaintext highlighter-rouge">pit_handler</code>中呼叫<code class="language-plaintext highlighter-rouge">scheduler_linkage (asm)</code></li> <li>进入scheduler后，先<strong>储存本次scheduler进入时的ebp</strong>，储存到<code class="language-plaintext highlighter-rouge">pcb→sch_ebp</code>中</li> <li>找到在schedule array中的下一个需要被schedule的process，以下称为<strong><code class="language-plaintext highlighter-rouge">next process</code></strong>，并更新<code class="language-plaintext highlighter-rouge">cur_sch_index</code>（用来指示当前schedule是哪个process的变量）</li> <li>若next process的pid为-2(TERM_NOT_INIT宏)，代表下一个terminal上还没有被初始化任何进程 <ol> <li><code class="language-plaintext highlighter-rouge">remap_video_page(cur_sch_index)</code> 接下来的一切和video相关操作会作用在即将新开启的shell process上</li> <li>执行<code class="language-plaintext highlighter-rouge">execute('shell')</code></li> </ol> <aside> ➡️ 这样做可以解决刚开始三个process的kernel stack上都没有scheduler残余的问题。三个空的kernel stack会一个个被初始化成为有scheduler残余的kernel stack </aside> </li> <li> <p>如果下一个terminal已经有进程可以被schedule了：为进入user space做准备，对user program的map进行调整，即对program image进行更改</p> <p>将user program部分指向physical memory中next process的program image。和execute使用一个更改user program paging的函数</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cm">/*   set_user_prog_page
  *   Set page for a user program
  *   input: pid -- the pid of the user program
  *   output: None
  *   side effect: Change the paging directory; Change CR3; flush TLB */</span>
</code></pre></div> </div> </li> <li>改变TSS，为回到kernel space做准备</li> <li>remap user video memory</li> <li> <p>准备context switch到即将切换到的process</p> <p>不能直接使用iret，而是<strong>重新载入另一个process的ebp</strong>，只是相当于换了一个kernel stack</p> <ol> <li>在scheduler中，将next process <code class="language-plaintext highlighter-rouge">pcb→ sch_ebp</code>取出来，这个ebp储存的是上一次从刚刚进入scheduler时的stack state</li> <li>将这个pcb→sch_ebp赋值给ebp，再leave+ret，实际上是从next process kernel stack上回到了pit handler</li> </ol> </li> <li>在切换stack之后，回到了PIT handler，PIT handler再return，则可以利用PIT lnk(asm)中的iret，可以switch到next process的user space</li> </ol> <hr/> <p><img src="Untitled18.png" alt="Untitled" width="850"/></p> <p>virtual的0xB8000指向scheduled process的backup buffer，如果和display terminal是一个，则指向physical的0xB8000</p> <p>键盘的字符永远要输入到physical的0xB8000</p> <h3 id="video-memory-problems">Video memory problems</h3> <p>上述实现逻辑会造成video memory出现一定的错乱问题，需要对<code class="language-plaintext highlighter-rouge">lib.c</code>中的<code class="language-plaintext highlighter-rouge">putc</code>函数进行一定的更改</p> <p>keyboard interrupt呼叫putc，默认朝0xB8000进行输入。但在schedule过程中，0xB8000因为video_remap的原因，未必时刻指向真实的video memory，可能指向backup buffer。但实际上，keyboard的输入应该显示在当前展示的terminal上，而非当前scheduled的terminal上。</p> <p>而terminal_write中呼叫的putc，则需要显示在当前scheduled的terminal上，而非当前展示的terminal，这与keyboard逻辑有所不同</p> <p>在已经提供的许多user program中，大多数向屏幕上打印的方法是呼叫terminal_write，而<code class="language-plaintext highlighter-rouge">fish.c</code>是使用<code class="language-plaintext highlighter-rouge">vidmap</code>直接获取地址然后修改值</p> <p>这一部分比较繁琐细碎，但并不困难，这个笔记里不过多赘述。</p> <hr/> <h1 id="extra-credit">Extra Credit</h1> <h2 id="memory-allocation">Memory Allocation</h2> <p>Two types of memory management</p> <ol> <li>Fixed length memory allocation</li> <li>Varaible length memory allocation</li> </ol> <h3 id="fixed-length--slab-cache">Fixed length — Slab Cache</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">In</span> <span class="n">this</span> <span class="n">specific</span> <span class="n">implementation</span><span class="p">,</span> <span class="n">fixed</span> <span class="n">length</span> <span class="n">memory</span> <span class="n">allocation</span> <span class="n">is</span> <span class="n">implemented</span> <span class="n">by</span> <span class="n">two</span> <span class="n">parts</span><span class="p">,</span> <span class="n">memory</span> <span class="n">management</span> <span class="n">unit</span> <span class="n">and</span> <span class="n">memory</span> <span class="n">unit</span><span class="p">.</span>
<span class="n">fixed</span> <span class="n">length</span> <span class="n">diagram</span><span class="o">:</span>
        <span class="o">|</span><span class="n">memory</span> <span class="n">management</span> <span class="n">unit</span><span class="o">|</span>  <span class="o">|</span><span class="n">memory</span> <span class="n">management</span> <span class="n">unit</span><span class="o">|</span>  <span class="o">|</span><span class="n">memory</span> <span class="n">management</span> <span class="n">unit</span><span class="o">|</span>  <span class="p">..........</span>    <span class="o">|</span><span class="n">memory</span> <span class="n">unit</span><span class="o">|</span>  <span class="o">|</span><span class="n">memory</span> <span class="n">unit</span><span class="o">|</span> <span class="o">|</span><span class="n">memory</span> <span class="n">unit</span><span class="o">|</span> <span class="p">.....</span>
        <span class="o">|</span><span class="n">next</span><span class="o">|</span>  <span class="o">---------------&gt;</span>  <span class="o">|</span><span class="n">next</span><span class="o">|</span>  <span class="o">---------------&gt;</span>  <span class="o">|</span><span class="n">next</span><span class="o">|</span>                                      <span class="err">↑</span>              <span class="err">↑</span>             <span class="err">↑</span>
        <span class="o">|</span><span class="n">ptr</span><span class="o">|---------------------|</span><span class="n">ptr</span><span class="o">|---------------------|</span><span class="n">ptr</span><span class="o">|---------------------------------------</span><span class="err">↑</span><span class="o">--------------</span><span class="err">↑</span><span class="o">-------------</span><span class="err">↑</span>
</code></pre></div></div> <p>Data structure: Linked list</p> <ul> <li>Slab_Create ( name , size )</li> <li>destroy , malloc , free</li> <li>Automatically shrinks and grows</li> <li>quick and fast to allocate and free</li> <li>granularity: 1byte - 4kB-8 bytes</li> </ul> <h3 id="variable-length--implicit-free-list">Variable length — Implicit free list</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">On</span> <span class="n">the</span> <span class="n">other</span> <span class="n">hand</span><span class="p">,</span> <span class="n">variable</span> <span class="n">length</span> <span class="n">memory</span> <span class="n">allocation</span> <span class="n">is</span> <span class="n">implemented</span> <span class="n">very</span> <span class="n">similar</span> <span class="n">to</span> <span class="n">Linux</span><span class="err">'</span><span class="n">s</span> <span class="n">implicit</span> <span class="n">free</span> <span class="n">list</span> <span class="n">design</span><span class="p">.</span> 
<span class="n">A</span> <span class="n">memory</span> <span class="n">part</span> <span class="n">consists</span> <span class="n">of</span> <span class="n">two</span> <span class="n">parts</span><span class="p">,</span> <span class="n">memory</span> <span class="n">management</span> <span class="n">unit</span> <span class="n">and</span> <span class="n">real</span> <span class="n">useable</span> <span class="n">memory</span> <span class="n">unit</span><span class="p">.</span>
<span class="n">Memory</span> <span class="n">management</span> <span class="n">units</span> <span class="n">are</span> <span class="n">held</span> <span class="n">in</span> <span class="n">a</span> <span class="n">linked</span> <span class="n">list</span> <span class="n">to</span> <span class="n">track</span> <span class="n">each</span> <span class="n">memory</span> <span class="n">fragments</span> <span class="n">have</span> <span class="n">been</span> <span class="n">allocated</span><span class="p">.</span>
<span class="n">variable</span> <span class="n">length</span> <span class="n">diagram</span><span class="o">:</span>
        <span class="o">|</span><span class="n">memory</span> <span class="n">mangement</span> <span class="n">unit</span><span class="o">|</span> <span class="o">-&gt;</span> <span class="o">|</span><span class="n">memory</span> <span class="n">mangement</span> <span class="n">unit</span><span class="o">|</span> <span class="o">-&gt;</span> <span class="o">|</span><span class="n">memory</span> <span class="n">mangement</span> <span class="n">unit</span><span class="o">|</span> <span class="o">-&gt;</span> <span class="o">|</span><span class="n">memory</span> <span class="n">mangement</span> <span class="n">unit</span><span class="o">|</span>
        <span class="o">-----------------------</span>    <span class="o">-----------------------</span>    <span class="o">-----------------------</span>    <span class="o">-----------------------</span>
        <span class="o">|</span>                     <span class="o">|</span>    <span class="o">|</span>                     <span class="o">|</span>    <span class="o">|</span>                     <span class="o">|</span>    <span class="o">|</span>                     <span class="o">|</span>
        <span class="o">|</span>   <span class="n">useable</span> <span class="n">memory</span>    <span class="o">|</span>    <span class="o">|</span>   <span class="n">useable</span> <span class="n">memory</span>    <span class="o">|</span>    <span class="o">|</span>   <span class="n">useable</span> <span class="n">memory</span>    <span class="o">|</span>    <span class="o">|</span>   <span class="n">useable</span> <span class="n">memory</span>    <span class="o">|</span>
        <span class="o">|</span>                     <span class="o">|</span>    <span class="o">|</span>                     <span class="o">|</span>    <span class="o">-----------------------</span>    <span class="o">|</span>                     <span class="o">|</span>
        <span class="o">|</span>                     <span class="o">|</span>    <span class="o">-----------------------</span>                               <span class="o">-----------------------</span>
        <span class="o">|</span>                     <span class="o">|</span>
        <span class="o">-----------------------</span>

<span class="n">Slab</span> <span class="n">cache</span><span class="err">'</span><span class="n">s</span> <span class="n">implementation</span> <span class="n">is</span> <span class="n">based</span> <span class="n">on</span> <span class="n">fixed</span> <span class="n">length</span> <span class="n">memory</span> <span class="n">allocation</span><span class="p">.</span>
</code></pre></div></div> <p>Data structure: Implicit free list</p> <ul> <li>varmalloc( size )</li> <li>flexible: can allocate any size</li> <li>granularity: 1byte - 4MB</li> </ul> <h2 id="signal">Signal</h2> <p>Support users to set handler they define</p> <p>Support sigreturn and set_handler syscall</p> <p>Support five signals:</p> <ol> <li>SIG_DIV_ZERO</li> <li>SIG_SEGFAULT</li> <li>SIG_INTERRUPT</li> <li>SIG_ALARM</li> <li>SIG_USER1</li> </ol> <h2 id="ata-hard-disk-support--file-system">ATA Hard Disk Support &amp; File System</h2> <ul> <li> <p>Writable file system</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nx">write</span> <span class="nx">fname</span> <span class="nx">contents</span>
</code></pre></div> </div> </li> <li>Persistent Change (after reboot) by saving the change to the hard drive</li> <li>How the file system is loaded and initialized:</li> </ul> <p><img src="Untitled19.png" alt="Untitled"/></p> <h2 id="speaker-driver">Speaker Driver</h2> <p>Toggle <strong>**</strong><strong>**</strong><strong>NumLock</strong><strong>**</strong><strong>**</strong> to turn on/off</p> <p>Key mapping:</p> <p>(C3~E4) ZSXDCVGBHNJM,L.;/</p> <p>(C4~G5) Q2W3ER5T6Y7UI9O0P[=]</p> <p>Runs concurrently with any user programs &amp; across terminals</p>]]></content><author><name></name></author><category term="course-notes"/><summary type="html"><![CDATA[A tutorial and tips for ECE391 MP3.]]></summary></entry></feed>